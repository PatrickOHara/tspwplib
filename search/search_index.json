{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tspwplib","text":"<p>A library for graph instances of the Travelling Salesman Problem with Profits.</p> <p>Get an instance of the Orienteering Problem:</p> <pre><code>import os\nfrom tspwplib import *\n\noplib_root = os.getenv(\"OPLIB_ROOT\")    # TODO set your path to oplib\nfilepath = build_path_to_oplib_instance(\n    oplib_root, Generation.gen1, GraphName.st70\n)\nproblem = ProfitsProblem.load(filepath)\n</code></pre> <p>Get a networkx graph with attributes for prize on the vertices and cost on the edges:</p> <pre><code>nx_graph = problem.get_graph()\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This library relies heavily upon tsplib95 and OPLib.</p>"},{"location":"api/","title":"API","text":"<p>Travelling Salesman Problem with Profits library</p>"},{"location":"api/#tspwplib.Alpha","title":"<code>Alpha</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>Ratio between profit/cost limit and profit/cost of TSP solution</p> Source code in <code>tspwplib/types.py</code> <pre><code>class Alpha(IntEnum):\n    \"\"\"Ratio between profit/cost limit and profit/cost of TSP solution\"\"\"\n\n    fifty = 50\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP","title":"<code>BaseTSP</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A pydantic model for tsplib95.</p> <p>Each field is validated with type hinting.</p> Source code in <code>tspwplib/problem.py</code> <pre><code>class BaseTSP(pydantic.BaseModel):\n    \"\"\"A pydantic model for tsplib95.\n\n    Each field is validated with type hinting.\n    \"\"\"\n\n    # pylint: disable=too-many-arguments\n\n    capacity: Optional[Union[int, float]] = None\n    comment: str\n    demands: Optional[VertexFunction]\n    depots: VertexList\n    dimension: int\n    display_data: Optional[NodeCoords] = None\n    display_data_type: DisplayDataType\n    edge_data: SimpleEdgeList\n    edge_data_format: EdgeDataFormat\n    edge_weights: Optional[SimpleEdgeFunction] = None\n    edge_weight_format: EdgeWeightFormat\n    edge_weight_type: EdgeWeightType\n    fixed_edges: SimpleEdgeList\n    name: str\n    node_coords: Optional[NodeCoords] = None\n    node_coord_type: NodeCoordType\n    problem_type: str\n    tours: Optional[List[VertexList]] = None\n\n    # pydantic model config\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    @classmethod\n    def from_networkx(\n        cls,\n        name: str,\n        comment: str,\n        problem_type: str,\n        G: nx.Graph,\n        capacity: Optional[Union[int, float]] = None,\n        display_data: Optional[NodeCoords] = None,\n        display_data_type: DisplayDataType = DisplayDataType.NO_DISPLAY,\n        edge_weight_format: EdgeWeightFormat = EdgeWeightFormat.FULL_MATRIX,\n        weight_attr_name: str = \"weight\",\n    ):\n        \"\"\"Get a base TSP model from a networkx graph\"\"\"\n        edge_attr_names = edge_attribute_names(G)\n        node_attr_names = node_attribute_names(G)\n        if weight_attr_name not in edge_attr_names:\n            message = f\"{weight_attr_name} is required to be an edge attribute, \"\n            message += \"but was not found in graph. \"\n            message += \"This function only supports an explicit weight function. \"\n            raise NotImplementedError(message)\n        is_2d = \"x\" in node_attr_names and \"y\" in node_attr_names\n        is_3d = is_2d and \"z\" in node_attr_names\n        if is_3d:\n            raise NotImplementedError(\"3D coords are not supported\")\n            # node_coord_type = NodeCoordType.THREED_COORDS\n            # node_coords = {\n            #     node: (float(data[\"x\"]), float(data[\"y\"]), float(data[\"z\"]))\n            #     for node, data in G.nodes(data=True)\n            # }\n        if is_2d:\n            node_coord_type = NodeCoordType.TWOD_COORDS\n            node_coords = {\n                node: (float(data[\"x\"]), float(data[\"y\"]))\n                for node, data in G.nodes(data=True)\n            }\n        else:\n            node_coord_type = NodeCoordType.NO_COORDS\n            node_coords = {}\n\n        demands = None\n        if \"demand\" in node_attr_names:\n            demands = nx.get_node_attributes(G, \"demand\")\n        if display_data_type == DisplayDataType.COORD_DISPLAY:\n            display_data = node_coords\n\n        fixed_edges = []\n        if \"is_fixed\" in edge_attr_names:\n            fixed_edges = [\n                (u, v) for u, v, data in G.edges(data=True) if data[\"is_fixed\"]\n            ]\n\n        depots = []\n        if \"is_depot\" in node_attr_names:\n            depots = [node for node, data in G.nodes(data=True) if data[\"is_depot\"]]\n        edge_data = list(G.edges())\n        edge_weights = nx.get_edge_attributes(G, weight_attr_name)\n        return cls(\n            capacity=capacity,\n            comment=comment,\n            demands=demands,\n            depots=depots,\n            dimension=G.number_of_nodes(),\n            display_data=display_data,\n            display_data_type=display_data_type,\n            edge_data=edge_data,\n            edge_data_format=EdgeDataFormat.EDGE_LIST,\n            edge_weights=edge_weights,\n            edge_weight_format=edge_weight_format,\n            edge_weight_type=EdgeWeightType.EXPLICIT,\n            fixed_edges=fixed_edges,\n            name=name,\n            node_coords=node_coords,\n            node_coord_type=node_coord_type,\n            problem_type=problem_type,\n            tours=None,\n        )\n\n    @classmethod\n    def from_dataframes(\n        cls,\n        name: str,\n        comment: str,\n        problem_type: str,\n        edges_df: pd.DataFrame,\n        nodes_df: pd.DataFrame,\n        capacity: Optional[Union[int, float]] = None,\n        display_data: Optional[NodeCoords] = None,\n        display_data_type: DisplayDataType = DisplayDataType.NO_DISPLAY,\n        edge_weight_format: EdgeWeightFormat = EdgeWeightFormat.FULL_MATRIX,\n    ):\n        \"\"\"Get a TSP base model from edge and node dataframes\n\n        Notes:\n            Essential edge columns: [source, target, weight].\n            Optional edge columns: [is_fixed].\n            Essential node columns: [node, is_depot].\n            Optional node columns: [x, y, z, demand].\n            The edge weight function is explicitly given by the 'weight' column.\n        \"\"\"\n        if \"weight\" not in edges_df:\n            message = \"'weight' is not a column in edges_df. \"\n            message += \"This function only supports an explicit weight function. \"\n            message += \"If you have a column that can be used as the weight function, \"\n            message += \"please rename the column to 'weight'.\"\n            raise NotImplementedError(message)\n        is_2d = \"x\" in nodes_df.columns and \"y\" in nodes_df.columns\n        is_3d = is_2d and \"z\" in nodes_df.columns\n        if is_3d:\n            raise NotImplementedError(\"3D coords not supported\")\n        if is_2d:\n            node_coord_type = NodeCoordType.TWOD_COORDS\n            node_coords = dict(zip(nodes_df[\"node\"], zip(nodes_df[\"x\"], nodes_df[\"y\"])))\n        else:\n            node_coord_type = NodeCoordType.NO_COORDS\n            node_coords = {}\n\n        demands = None\n        if \"demand\" in nodes_df.columns:\n            demands = dict(zip(nodes_df[\"node\"], nodes_df[\"demand\"]))\n\n        if display_data_type == DisplayDataType.COORD_DISPLAY:\n            display_data = node_coords\n\n        fixed_edges = []\n        if \"is_fixed\" in edges_df.columns:\n            fixed_edges_df = edges_df.loc[edges_df[\"is_fixed\"]]\n            fixed_edges = list(zip(fixed_edges_df[\"source\"], fixed_edges_df[\"target\"]))\n\n        depots = nodes_df.loc[nodes_df[\"is_depot\"]][\"node\"].to_list()\n        edge_data = list(zip(edges_df[\"source\"], edges_df[\"target\"]))\n        edge_weights = dict(zip(edge_data, edges_df[\"weight\"]))\n        return cls(\n            capacity=capacity,\n            comment=comment,\n            demands=demands,\n            depots=depots,\n            dimension=len(nodes_df[\"node\"]),\n            display_data=display_data,\n            display_data_type=display_data_type,\n            edge_data=edge_data,\n            edge_data_format=EdgeDataFormat.EDGE_LIST,\n            edge_weights=edge_weights,\n            edge_weight_format=edge_weight_format,\n            edge_weight_type=EdgeWeightType.EXPLICIT,\n            fixed_edges=fixed_edges,\n            name=name,\n            node_coords=node_coords,\n            node_coord_type=node_coord_type,\n            problem_type=problem_type,\n            tours=None,\n        )\n\n    @classmethod\n    def from_tsplib95(cls, problem: tsplib95.models.StandardProblem):\n        \"\"\"Get a TSP base model from a StandardProblem object\"\"\"\n\n        display_data_type = (\n            problem.display_data_type\n            if problem.display_data_type\n            else DisplayDataType.NO_DISPLAY\n        )\n        edge_data_format = (\n            problem.edge_data_format\n            if problem.edge_data_format\n            else EdgeDataFormat.EDGE_LIST\n        )\n        edge_weight_type = problem.edge_weight_type\n\n        # edge weight format\n        edge_weight_format = problem.edge_weight_format\n        if edge_weight_type == EdgeWeightType.UNIFORM_RANDOM:\n            edge_weight_format = EdgeWeightFormat.FUNCTION\n            weights = uniform_random_cost(list(problem.get_edges()))\n        elif (\n            not edge_weight_format\n            and edge_weight_type in EdgeWeightType.__members__\n            and edge_weight_type != EdgeWeightType.EXPLICIT\n        ):\n            edge_weight_format = EdgeWeightFormat.FUNCTION\n            weights = {(i, j): problem.get_weight(i, j) for i, j in problem.get_edges()}\n        elif not edge_weight_format and edge_weight_type == EdgeWeightType.EXPLICIT:\n            raise ValueError(\n                \"Edge weight type is set to EXPLICIT but no edge weight format is given\"\n            )\n        elif not edge_weight_format:\n            raise ValueError(\n                \"Edge weight format in StandardProblem is not set - cannot assign edge weights.\"\n            )\n        else:\n            weights = {(i, j): problem.get_weight(i, j) for i, j in problem.get_edges()}\n\n        node_coord_type = (\n            problem.node_coord_type\n            if problem.node_coord_type\n            else NodeCoordType.NO_COORDS\n        )\n        node_coords = None\n        if node_coord_type == NodeCoordType.TWOD_COORDS:\n            node_coords = {i: problem.node_coords.get(i) for i in problem.get_nodes()}\n        elif node_coord_type == NodeCoordType.THREED_COORDS:\n            raise NotImplementedError(\"3D coords not yet supported\")\n\n        return cls(\n            capacity=problem.capacity,\n            comment=problem.comment if problem.comment else \"\",\n            demands=problem.demands,\n            depots=problem.depots,\n            dimension=problem.dimension,\n            display_data=problem.display_data,\n            display_data_type=display_data_type,\n            edge_data=list(problem.get_edges()),\n            edge_data_format=edge_data_format,\n            edge_weights=weights,\n            edge_weight_format=edge_weight_format,\n            edge_weight_type=edge_weight_type,\n            fixed_edges=problem.fixed_edges,\n            name=problem.name,\n            node_coords=node_coords,\n            node_coord_type=node_coord_type,\n            problem_type=problem.type,\n            tours=problem.tours,\n        )\n\n    @no_type_check\n    def to_tsplib95(self) -&gt; tsplib95.models.StandardProblem:\n        \"\"\"Convert to a tsplib95 standard model\"\"\"\n        weights = None\n        if self.edge_weight_type == EdgeWeightType.EXPLICIT:\n            weights = self.get_weighted_full_matrix()\n\n        optional_kwargs = {}\n        if not self.capacity is None:\n            optional_kwargs[\"capacity\"] = self.capacity\n        if self.display_data:\n            optional_kwargs[\"display_data\"] = self.display_data\n        if self.fixed_edges:\n            optional_kwargs[\"fixed_edges\"] = self.fixed_edges\n        if self.tours:\n            optional_kwargs[\"tours\"] = self.tours\n        return tsplib95.models.StandardProblem(\n            comment=self.comment,\n            demands=self.demands,\n            depots=self.depots,\n            dimension=self.dimension,\n            display_data_type=self.display_data_type,\n            edge_data=self.edge_data,\n            edge_data_format=self.edge_data_format,\n            edge_weights=weights,\n            edge_weight_format=self.edge_weight_format,\n            edge_weight_type=self.edge_weight_type,\n            name=self.name,\n            node_coords=self.node_coords,\n            node_coord_type=self.node_coord_type,\n            type=self.problem_type,\n            **optional_kwargs,\n        )\n\n    @classmethod\n    def from_yaml(cls, yaml_filepath: Path):\n        \"\"\"Load from a yaml file\"\"\"\n        with open(yaml_filepath, \"r\", encoding=\"utf-8\") as yaml_file:\n            yaml_dict = yaml.load(yaml_file, Loader=yaml.FullLoader)\n        edge_data = edge_list_from_adjacency_list(yaml_dict.pop(\"edge_data\"))\n        edge_weights = edge_dict_from_adjacency_weights(yaml_dict.pop(\"edge_weights\"))\n        fixed_edges = edge_list_from_adjacency_list(yaml_dict.pop(\"fixed_edges\"))\n        return cls(\n            **yaml_dict,\n            edge_data=edge_data,\n            edge_weights=edge_weights,\n            fixed_edges=fixed_edges,\n        )\n\n    def to_yaml(self, yaml_filepath: Path) -&gt; None:\n        \"\"\"Dump the TSP to a YAML file\"\"\"\n        yaml_dict = dict(\n            comment=self.comment,\n            demands=self.demands,\n            depots=self.depots,\n            dimension=self.dimension,\n            display_data_type=self.display_data_type.value,\n            edge_data=adjacency_list_from_edge_list(self.edge_data),\n            edge_data_format=self.edge_data_format.value,\n            edge_weight_format=self.edge_weight_format.value,\n            edge_weight_type=self.edge_weight_type.value,\n            fixed_edges=adjacency_list_from_edge_list(self.fixed_edges),\n            name=self.name,\n            node_coords=self.node_coords,\n            node_coord_type=self.node_coord_type.value,\n            problem_type=self.problem_type,\n            tours=self.tours,\n        )\n        if self.edge_weights:\n            weights: AdjWeights = adjacency_weights_from_edge_dict(self.edge_weights)\n            yaml_dict[\"edge_weights\"] = weights  # type: ignore\n        else:\n            yaml_dict[\"edge_weights\"] = None\n        with open(yaml_filepath, \"w\", encoding=\"utf-8\") as yaml_file:\n            yaml.dump(yaml_dict, yaml_file)\n\n    def get_weighted_full_matrix(self) -&gt; npt.NDArray[np.int_]:\n        \"\"\"Get a square weighted adjacency matrix, sorted by node ID\"\"\"\n        # create a graph\n        G = self.get_graph()\n        # sort the node list (ascending)\n        sorted_node_list = list(G.nodes())\n        sorted_node_list.sort()\n        # then get the weighted adjacency matrix\n        return nx.to_numpy_array(\n            G, nodelist=sorted_node_list, weight=\"weight\", dtype=int\n        )\n\n    def __set_graph_attributes(self, graph: nx.Graph) -&gt; None:\n        \"\"\"Set graph attributes such as 'name' and 'comment'\"\"\"\n        graph.graph[\"name\"] = self.name\n        graph.graph[\"comment\"] = self.comment\n        graph.graph[\"problem_type\"] = self.problem_type\n        graph.graph[\"dimension\"] = self.dimension\n        if not self.capacity is None:\n            graph.graph[\"capacity\"] = self.capacity\n\n    def __set_node_attributes(self, graph: nx.Graph) -&gt; None:\n        \"\"\"Set node attributes\"\"\"\n        for vertex in graph.nodes():\n            graph.nodes[vertex][\"is_depot\"] = vertex in self.depots\n            if self.demands:\n                graph.nodes[vertex][\"demand\"] = self.demands[vertex]\n            if self.display_data:\n                graph.nodes[vertex][\"display\"] = self.display_data[vertex]\n            if self.node_coords:\n                coords = self.node_coords[vertex]\n                graph.nodes[vertex][\"x\"] = coords[0]\n                graph.nodes[vertex][\"y\"] = coords[1]\n\n    def __add_edges(self, graph: nx.Graph) -&gt; None:\n        \"\"\"Add edges from edge data\n\n        Args:\n            graph: Input graph\n        \"\"\"\n        for edge in self.edge_data:\n            graph.add_edge(edge[0], edge[1])\n\n    def __set_edge_attributes(self, graph: nx.Graph) -&gt; None:\n        \"\"\"Set edge attributes for 'weight' and 'is_fixed'\n\n        Args:\n            graph: Input graph\n        \"\"\"\n        nx.set_edge_attributes(graph, self.edge_weights, name=\"weight\")\n        fixed = {(u, v): (u, v) in self.fixed_edges for u, v in graph.edges()}\n        nx.set_edge_attributes(graph, fixed, name=\"is_fixed\")\n\n    def get_graph(self) -&gt; nx.Graph:\n        \"\"\"Get a networkx graph\n\n        Returns:\n            Undirected networkx graph with node attributes such as 'is_depot'\n            and edge attributes such as 'weight' and 'is_fixed'.\n        \"\"\"\n        G = nx.Graph()\n        self.__set_graph_attributes(G)\n        self.__add_edges(G)\n        self.__set_edge_attributes(G)\n        self.__set_node_attributes(G)\n        return G\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.__add_edges","title":"<code>__add_edges(graph)</code>","text":"<p>Add edges from edge data</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Input graph</p> required Source code in <code>tspwplib/problem.py</code> <pre><code>def __add_edges(self, graph: nx.Graph) -&gt; None:\n    \"\"\"Add edges from edge data\n\n    Args:\n        graph: Input graph\n    \"\"\"\n    for edge in self.edge_data:\n        graph.add_edge(edge[0], edge[1])\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.__set_edge_attributes","title":"<code>__set_edge_attributes(graph)</code>","text":"<p>Set edge attributes for 'weight' and 'is_fixed'</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Input graph</p> required Source code in <code>tspwplib/problem.py</code> <pre><code>def __set_edge_attributes(self, graph: nx.Graph) -&gt; None:\n    \"\"\"Set edge attributes for 'weight' and 'is_fixed'\n\n    Args:\n        graph: Input graph\n    \"\"\"\n    nx.set_edge_attributes(graph, self.edge_weights, name=\"weight\")\n    fixed = {(u, v): (u, v) in self.fixed_edges for u, v in graph.edges()}\n    nx.set_edge_attributes(graph, fixed, name=\"is_fixed\")\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.__set_graph_attributes","title":"<code>__set_graph_attributes(graph)</code>","text":"<p>Set graph attributes such as 'name' and 'comment'</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def __set_graph_attributes(self, graph: nx.Graph) -&gt; None:\n    \"\"\"Set graph attributes such as 'name' and 'comment'\"\"\"\n    graph.graph[\"name\"] = self.name\n    graph.graph[\"comment\"] = self.comment\n    graph.graph[\"problem_type\"] = self.problem_type\n    graph.graph[\"dimension\"] = self.dimension\n    if not self.capacity is None:\n        graph.graph[\"capacity\"] = self.capacity\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.__set_node_attributes","title":"<code>__set_node_attributes(graph)</code>","text":"<p>Set node attributes</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def __set_node_attributes(self, graph: nx.Graph) -&gt; None:\n    \"\"\"Set node attributes\"\"\"\n    for vertex in graph.nodes():\n        graph.nodes[vertex][\"is_depot\"] = vertex in self.depots\n        if self.demands:\n            graph.nodes[vertex][\"demand\"] = self.demands[vertex]\n        if self.display_data:\n            graph.nodes[vertex][\"display\"] = self.display_data[vertex]\n        if self.node_coords:\n            coords = self.node_coords[vertex]\n            graph.nodes[vertex][\"x\"] = coords[0]\n            graph.nodes[vertex][\"y\"] = coords[1]\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.from_dataframes","title":"<code>from_dataframes(name, comment, problem_type, edges_df, nodes_df, capacity=None, display_data=None, display_data_type=DisplayDataType.NO_DISPLAY, edge_weight_format=EdgeWeightFormat.FULL_MATRIX)</code>  <code>classmethod</code>","text":"<p>Get a TSP base model from edge and node dataframes</p> Notes <p>Essential edge columns: [source, target, weight]. Optional edge columns: [is_fixed]. Essential node columns: [node, is_depot]. Optional node columns: [x, y, z, demand]. The edge weight function is explicitly given by the 'weight' column.</p> Source code in <code>tspwplib/problem.py</code> <pre><code>@classmethod\ndef from_dataframes(\n    cls,\n    name: str,\n    comment: str,\n    problem_type: str,\n    edges_df: pd.DataFrame,\n    nodes_df: pd.DataFrame,\n    capacity: Optional[Union[int, float]] = None,\n    display_data: Optional[NodeCoords] = None,\n    display_data_type: DisplayDataType = DisplayDataType.NO_DISPLAY,\n    edge_weight_format: EdgeWeightFormat = EdgeWeightFormat.FULL_MATRIX,\n):\n    \"\"\"Get a TSP base model from edge and node dataframes\n\n    Notes:\n        Essential edge columns: [source, target, weight].\n        Optional edge columns: [is_fixed].\n        Essential node columns: [node, is_depot].\n        Optional node columns: [x, y, z, demand].\n        The edge weight function is explicitly given by the 'weight' column.\n    \"\"\"\n    if \"weight\" not in edges_df:\n        message = \"'weight' is not a column in edges_df. \"\n        message += \"This function only supports an explicit weight function. \"\n        message += \"If you have a column that can be used as the weight function, \"\n        message += \"please rename the column to 'weight'.\"\n        raise NotImplementedError(message)\n    is_2d = \"x\" in nodes_df.columns and \"y\" in nodes_df.columns\n    is_3d = is_2d and \"z\" in nodes_df.columns\n    if is_3d:\n        raise NotImplementedError(\"3D coords not supported\")\n    if is_2d:\n        node_coord_type = NodeCoordType.TWOD_COORDS\n        node_coords = dict(zip(nodes_df[\"node\"], zip(nodes_df[\"x\"], nodes_df[\"y\"])))\n    else:\n        node_coord_type = NodeCoordType.NO_COORDS\n        node_coords = {}\n\n    demands = None\n    if \"demand\" in nodes_df.columns:\n        demands = dict(zip(nodes_df[\"node\"], nodes_df[\"demand\"]))\n\n    if display_data_type == DisplayDataType.COORD_DISPLAY:\n        display_data = node_coords\n\n    fixed_edges = []\n    if \"is_fixed\" in edges_df.columns:\n        fixed_edges_df = edges_df.loc[edges_df[\"is_fixed\"]]\n        fixed_edges = list(zip(fixed_edges_df[\"source\"], fixed_edges_df[\"target\"]))\n\n    depots = nodes_df.loc[nodes_df[\"is_depot\"]][\"node\"].to_list()\n    edge_data = list(zip(edges_df[\"source\"], edges_df[\"target\"]))\n    edge_weights = dict(zip(edge_data, edges_df[\"weight\"]))\n    return cls(\n        capacity=capacity,\n        comment=comment,\n        demands=demands,\n        depots=depots,\n        dimension=len(nodes_df[\"node\"]),\n        display_data=display_data,\n        display_data_type=display_data_type,\n        edge_data=edge_data,\n        edge_data_format=EdgeDataFormat.EDGE_LIST,\n        edge_weights=edge_weights,\n        edge_weight_format=edge_weight_format,\n        edge_weight_type=EdgeWeightType.EXPLICIT,\n        fixed_edges=fixed_edges,\n        name=name,\n        node_coords=node_coords,\n        node_coord_type=node_coord_type,\n        problem_type=problem_type,\n        tours=None,\n    )\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.from_networkx","title":"<code>from_networkx(name, comment, problem_type, G, capacity=None, display_data=None, display_data_type=DisplayDataType.NO_DISPLAY, edge_weight_format=EdgeWeightFormat.FULL_MATRIX, weight_attr_name='weight')</code>  <code>classmethod</code>","text":"<p>Get a base TSP model from a networkx graph</p> Source code in <code>tspwplib/problem.py</code> <pre><code>@classmethod\ndef from_networkx(\n    cls,\n    name: str,\n    comment: str,\n    problem_type: str,\n    G: nx.Graph,\n    capacity: Optional[Union[int, float]] = None,\n    display_data: Optional[NodeCoords] = None,\n    display_data_type: DisplayDataType = DisplayDataType.NO_DISPLAY,\n    edge_weight_format: EdgeWeightFormat = EdgeWeightFormat.FULL_MATRIX,\n    weight_attr_name: str = \"weight\",\n):\n    \"\"\"Get a base TSP model from a networkx graph\"\"\"\n    edge_attr_names = edge_attribute_names(G)\n    node_attr_names = node_attribute_names(G)\n    if weight_attr_name not in edge_attr_names:\n        message = f\"{weight_attr_name} is required to be an edge attribute, \"\n        message += \"but was not found in graph. \"\n        message += \"This function only supports an explicit weight function. \"\n        raise NotImplementedError(message)\n    is_2d = \"x\" in node_attr_names and \"y\" in node_attr_names\n    is_3d = is_2d and \"z\" in node_attr_names\n    if is_3d:\n        raise NotImplementedError(\"3D coords are not supported\")\n        # node_coord_type = NodeCoordType.THREED_COORDS\n        # node_coords = {\n        #     node: (float(data[\"x\"]), float(data[\"y\"]), float(data[\"z\"]))\n        #     for node, data in G.nodes(data=True)\n        # }\n    if is_2d:\n        node_coord_type = NodeCoordType.TWOD_COORDS\n        node_coords = {\n            node: (float(data[\"x\"]), float(data[\"y\"]))\n            for node, data in G.nodes(data=True)\n        }\n    else:\n        node_coord_type = NodeCoordType.NO_COORDS\n        node_coords = {}\n\n    demands = None\n    if \"demand\" in node_attr_names:\n        demands = nx.get_node_attributes(G, \"demand\")\n    if display_data_type == DisplayDataType.COORD_DISPLAY:\n        display_data = node_coords\n\n    fixed_edges = []\n    if \"is_fixed\" in edge_attr_names:\n        fixed_edges = [\n            (u, v) for u, v, data in G.edges(data=True) if data[\"is_fixed\"]\n        ]\n\n    depots = []\n    if \"is_depot\" in node_attr_names:\n        depots = [node for node, data in G.nodes(data=True) if data[\"is_depot\"]]\n    edge_data = list(G.edges())\n    edge_weights = nx.get_edge_attributes(G, weight_attr_name)\n    return cls(\n        capacity=capacity,\n        comment=comment,\n        demands=demands,\n        depots=depots,\n        dimension=G.number_of_nodes(),\n        display_data=display_data,\n        display_data_type=display_data_type,\n        edge_data=edge_data,\n        edge_data_format=EdgeDataFormat.EDGE_LIST,\n        edge_weights=edge_weights,\n        edge_weight_format=edge_weight_format,\n        edge_weight_type=EdgeWeightType.EXPLICIT,\n        fixed_edges=fixed_edges,\n        name=name,\n        node_coords=node_coords,\n        node_coord_type=node_coord_type,\n        problem_type=problem_type,\n        tours=None,\n    )\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.from_tsplib95","title":"<code>from_tsplib95(problem)</code>  <code>classmethod</code>","text":"<p>Get a TSP base model from a StandardProblem object</p> Source code in <code>tspwplib/problem.py</code> <pre><code>@classmethod\ndef from_tsplib95(cls, problem: tsplib95.models.StandardProblem):\n    \"\"\"Get a TSP base model from a StandardProblem object\"\"\"\n\n    display_data_type = (\n        problem.display_data_type\n        if problem.display_data_type\n        else DisplayDataType.NO_DISPLAY\n    )\n    edge_data_format = (\n        problem.edge_data_format\n        if problem.edge_data_format\n        else EdgeDataFormat.EDGE_LIST\n    )\n    edge_weight_type = problem.edge_weight_type\n\n    # edge weight format\n    edge_weight_format = problem.edge_weight_format\n    if edge_weight_type == EdgeWeightType.UNIFORM_RANDOM:\n        edge_weight_format = EdgeWeightFormat.FUNCTION\n        weights = uniform_random_cost(list(problem.get_edges()))\n    elif (\n        not edge_weight_format\n        and edge_weight_type in EdgeWeightType.__members__\n        and edge_weight_type != EdgeWeightType.EXPLICIT\n    ):\n        edge_weight_format = EdgeWeightFormat.FUNCTION\n        weights = {(i, j): problem.get_weight(i, j) for i, j in problem.get_edges()}\n    elif not edge_weight_format and edge_weight_type == EdgeWeightType.EXPLICIT:\n        raise ValueError(\n            \"Edge weight type is set to EXPLICIT but no edge weight format is given\"\n        )\n    elif not edge_weight_format:\n        raise ValueError(\n            \"Edge weight format in StandardProblem is not set - cannot assign edge weights.\"\n        )\n    else:\n        weights = {(i, j): problem.get_weight(i, j) for i, j in problem.get_edges()}\n\n    node_coord_type = (\n        problem.node_coord_type\n        if problem.node_coord_type\n        else NodeCoordType.NO_COORDS\n    )\n    node_coords = None\n    if node_coord_type == NodeCoordType.TWOD_COORDS:\n        node_coords = {i: problem.node_coords.get(i) for i in problem.get_nodes()}\n    elif node_coord_type == NodeCoordType.THREED_COORDS:\n        raise NotImplementedError(\"3D coords not yet supported\")\n\n    return cls(\n        capacity=problem.capacity,\n        comment=problem.comment if problem.comment else \"\",\n        demands=problem.demands,\n        depots=problem.depots,\n        dimension=problem.dimension,\n        display_data=problem.display_data,\n        display_data_type=display_data_type,\n        edge_data=list(problem.get_edges()),\n        edge_data_format=edge_data_format,\n        edge_weights=weights,\n        edge_weight_format=edge_weight_format,\n        edge_weight_type=edge_weight_type,\n        fixed_edges=problem.fixed_edges,\n        name=problem.name,\n        node_coords=node_coords,\n        node_coord_type=node_coord_type,\n        problem_type=problem.type,\n        tours=problem.tours,\n    )\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.from_yaml","title":"<code>from_yaml(yaml_filepath)</code>  <code>classmethod</code>","text":"<p>Load from a yaml file</p> Source code in <code>tspwplib/problem.py</code> <pre><code>@classmethod\ndef from_yaml(cls, yaml_filepath: Path):\n    \"\"\"Load from a yaml file\"\"\"\n    with open(yaml_filepath, \"r\", encoding=\"utf-8\") as yaml_file:\n        yaml_dict = yaml.load(yaml_file, Loader=yaml.FullLoader)\n    edge_data = edge_list_from_adjacency_list(yaml_dict.pop(\"edge_data\"))\n    edge_weights = edge_dict_from_adjacency_weights(yaml_dict.pop(\"edge_weights\"))\n    fixed_edges = edge_list_from_adjacency_list(yaml_dict.pop(\"fixed_edges\"))\n    return cls(\n        **yaml_dict,\n        edge_data=edge_data,\n        edge_weights=edge_weights,\n        fixed_edges=fixed_edges,\n    )\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.get_graph","title":"<code>get_graph()</code>","text":"<p>Get a networkx graph</p> <p>Returns:</p> Type Description <code>Graph</code> <p>Undirected networkx graph with node attributes such as 'is_depot'</p> <code>Graph</code> <p>and edge attributes such as 'weight' and 'is_fixed'.</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_graph(self) -&gt; nx.Graph:\n    \"\"\"Get a networkx graph\n\n    Returns:\n        Undirected networkx graph with node attributes such as 'is_depot'\n        and edge attributes such as 'weight' and 'is_fixed'.\n    \"\"\"\n    G = nx.Graph()\n    self.__set_graph_attributes(G)\n    self.__add_edges(G)\n    self.__set_edge_attributes(G)\n    self.__set_node_attributes(G)\n    return G\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.get_weighted_full_matrix","title":"<code>get_weighted_full_matrix()</code>","text":"<p>Get a square weighted adjacency matrix, sorted by node ID</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_weighted_full_matrix(self) -&gt; npt.NDArray[np.int_]:\n    \"\"\"Get a square weighted adjacency matrix, sorted by node ID\"\"\"\n    # create a graph\n    G = self.get_graph()\n    # sort the node list (ascending)\n    sorted_node_list = list(G.nodes())\n    sorted_node_list.sort()\n    # then get the weighted adjacency matrix\n    return nx.to_numpy_array(\n        G, nodelist=sorted_node_list, weight=\"weight\", dtype=int\n    )\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.to_tsplib95","title":"<code>to_tsplib95()</code>","text":"<p>Convert to a tsplib95 standard model</p> Source code in <code>tspwplib/problem.py</code> <pre><code>@no_type_check\ndef to_tsplib95(self) -&gt; tsplib95.models.StandardProblem:\n    \"\"\"Convert to a tsplib95 standard model\"\"\"\n    weights = None\n    if self.edge_weight_type == EdgeWeightType.EXPLICIT:\n        weights = self.get_weighted_full_matrix()\n\n    optional_kwargs = {}\n    if not self.capacity is None:\n        optional_kwargs[\"capacity\"] = self.capacity\n    if self.display_data:\n        optional_kwargs[\"display_data\"] = self.display_data\n    if self.fixed_edges:\n        optional_kwargs[\"fixed_edges\"] = self.fixed_edges\n    if self.tours:\n        optional_kwargs[\"tours\"] = self.tours\n    return tsplib95.models.StandardProblem(\n        comment=self.comment,\n        demands=self.demands,\n        depots=self.depots,\n        dimension=self.dimension,\n        display_data_type=self.display_data_type,\n        edge_data=self.edge_data,\n        edge_data_format=self.edge_data_format,\n        edge_weights=weights,\n        edge_weight_format=self.edge_weight_format,\n        edge_weight_type=self.edge_weight_type,\n        name=self.name,\n        node_coords=self.node_coords,\n        node_coord_type=self.node_coord_type,\n        type=self.problem_type,\n        **optional_kwargs,\n    )\n</code></pre>"},{"location":"api/#tspwplib.BaseTSP.to_yaml","title":"<code>to_yaml(yaml_filepath)</code>","text":"<p>Dump the TSP to a YAML file</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def to_yaml(self, yaml_filepath: Path) -&gt; None:\n    \"\"\"Dump the TSP to a YAML file\"\"\"\n    yaml_dict = dict(\n        comment=self.comment,\n        demands=self.demands,\n        depots=self.depots,\n        dimension=self.dimension,\n        display_data_type=self.display_data_type.value,\n        edge_data=adjacency_list_from_edge_list(self.edge_data),\n        edge_data_format=self.edge_data_format.value,\n        edge_weight_format=self.edge_weight_format.value,\n        edge_weight_type=self.edge_weight_type.value,\n        fixed_edges=adjacency_list_from_edge_list(self.fixed_edges),\n        name=self.name,\n        node_coords=self.node_coords,\n        node_coord_type=self.node_coord_type.value,\n        problem_type=self.problem_type,\n        tours=self.tours,\n    )\n    if self.edge_weights:\n        weights: AdjWeights = adjacency_weights_from_edge_dict(self.edge_weights)\n        yaml_dict[\"edge_weights\"] = weights  # type: ignore\n    else:\n        yaml_dict[\"edge_weights\"] = None\n    with open(yaml_filepath, \"w\", encoding=\"utf-8\") as yaml_file:\n        yaml.dump(yaml_dict, yaml_file)\n</code></pre>"},{"location":"api/#tspwplib.EdgeFunctionName","title":"<code>EdgeFunctionName</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Valid names of functions on edges</p> Source code in <code>tspwplib/types.py</code> <pre><code>class EdgeFunctionName(StrEnumMixin, str, Enum):\n    \"\"\"Valid names of functions on edges\"\"\"\n\n    cost = \"cost\"\n    weight = \"weight\"\n</code></pre>"},{"location":"api/#tspwplib.EdgeNotFoundException","title":"<code>EdgeNotFoundException</code>","text":"<p>             Bases: <code>NetworkXException</code></p> <p>An edge could not be found in the graph</p> Source code in <code>tspwplib/exception.py</code> <pre><code>class EdgeNotFoundException(ex.NetworkXException):\n    \"\"\"An edge could not be found in the graph\"\"\"\n</code></pre>"},{"location":"api/#tspwplib.EdgeWeightType","title":"<code>EdgeWeightType</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Specifies how the edge weights (or distances) are given</p> Source code in <code>tspwplib/types.py</code> <pre><code>class EdgeWeightType(StrEnumMixin, str, Enum):\n    \"\"\"Specifies how the edge weights (or distances) are given\"\"\"\n\n    EXPLICIT = \"EXPLICIT\"  # Weights are listed explicitly in the corresponding section\n    EUC_2D = \"EUC_2D\"  # Weights are Euclidean distances in 2-D\n    EUC_3D = \"EUC_3D\"  # Weights are Euclidean distances in 3-D\n    MAX_2D = \"MAX_2D\"  # Weights are maximum distances in 2-D\n    MAX_3D = \"MAX_3D\"  # Weights are maximum distances in 3-D\n    MAN_2D = \"MAN_2D\"  # Weights are Manhattan distances in 2-D\n    MAN_3D = \"MAN_3D\"  # Weights are Manhattan distances in 3-D\n    CEIL_2D = \"CEIL_2D\"  # Weights are Euclidean distances in 2-D rounded up\n    GEO = \"GEO\"  # Weights are geographical distances\n    ATT = \"ATT\"  # Special distance function for problems att48 and att532\n    XRAY1 = (\n        \"XRAY1\"  # Special distance function for crystallography problems (Version 1)\n    )\n    XRAY2 = (\n        \"XRAY2\"  # Special distance function for crystallography problems (Version 2)\n    )\n    SPECIAL = \"SPECIAL\"  # There is a special distance function documented elsewhere\n    UNIFORM_RANDOM = \"UNIFORM_RANDOM\"\n    MST = \"MST\"\n    SEMI_MST = \"SEMI_MST\"\n</code></pre>"},{"location":"api/#tspwplib.EdgesNotAdjacentException","title":"<code>EdgesNotAdjacentException</code>","text":"<p>             Bases: <code>AmbiguousSolution</code></p> <p>An edge list has been given non-adjacent edges which is ambiguous</p> Source code in <code>tspwplib/exception.py</code> <pre><code>class EdgesNotAdjacentException(ex.AmbiguousSolution):\n    \"\"\"An edge list has been given non-adjacent edges which is ambiguous\"\"\"\n</code></pre>"},{"location":"api/#tspwplib.Generation","title":"<code>Generation</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Generations of TSPwP problem instances</p> Source code in <code>tspwplib/types.py</code> <pre><code>class Generation(StrEnumMixin, str, Enum):\n    \"\"\"Generations of TSPwP problem instances\"\"\"\n\n    gen1 = \"gen1\"\n    gen2 = \"gen2\"\n    gen3 = \"gen3\"\n</code></pre>"},{"location":"api/#tspwplib.GraphName","title":"<code>GraphName</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Names of TSPlib instances</p> Source code in <code>tspwplib/types.py</code> <pre><code>class GraphName(StrEnumMixin, str, Enum):\n    \"\"\"Names of TSPlib instances\"\"\"\n\n    a280 = \"a280\"\n    ali535 = \"ali535\"\n    att48 = \"att48\"\n    att532 = \"att532\"\n    bayg29 = \"bayg29\"\n    bays29 = \"bays29\"\n    berlin52 = \"berlin52\"\n    bier127 = \"bier127\"\n    brazil58 = \"brazil58\"\n    brd14051 = \"brd14051\"\n    brg180 = \"brg180\"\n    burma14 = \"burma14\"\n    ch130 = \"ch130\"\n    ch150 = \"ch150\"\n    d198 = \"d198\"\n    d493 = \"d493\"\n    d657 = \"d657\"\n    d1291 = \"d1291\"\n    d1655 = \"d1655\"\n    d2103 = \"d2103\"\n    d15112 = \"d15112\"\n    d18512 = \"d18512\"\n    dantzig42 = \"dantzig42\"\n    dsj1000 = \"dsj1000\"\n    eil51 = \"eil51\"\n    eil76 = \"eil76\"\n    eil101 = \"eil101\"\n    fl417 = \"fl417\"\n    fl1400 = \"fl1400\"\n    fl1577 = \"fl1577\"\n    fl3795 = \"fl3795\"\n    fnl4461 = \"fnl4461\"\n    fri26 = \"fri26\"\n    gil262 = \"gil262\"\n    gr17 = \"gr17\"\n    gr21 = \"gr21\"\n    gr24 = \"gr24\"\n    gr48 = \"gr48\"\n    gr96 = \"gr96\"\n    gr120 = \"gr120\"\n    gr137 = \"gr137\"\n    gr202 = \"gr202\"\n    gr229 = \"gr229\"\n    gr431 = \"gr431\"\n    gr666 = \"gr666\"\n    hk48 = \"hk48\"\n    kroA100 = \"kroA100\"\n    kroB100 = \"kroB100\"\n    kroC100 = \"kroC100\"\n    kroD100 = \"kroD100\"\n    kroE100 = \"kroE100\"\n    kroA150 = \"kroA150\"\n    kroB150 = \"kroB150\"\n    kroA200 = \"kroA200\"\n    kroB200 = \"kroB200\"\n    lin105 = \"lin105\"\n    lin318 = \"lin318\"\n    linhp318 = \"linhp318\"\n    nrw1379 = \"nrw1379\"\n    p654 = \"p654\"\n    pa561 = \"pa561\"\n    pcb442 = \"pcb442\"\n    pcb1173 = \"pcb1173\"\n    pcb3038 = \"pcb3038\"\n    pla7397 = \"pla7397\"\n    pla33810 = \"pla33810\"\n    pla85900 = \"pla85900\"\n    pr76 = \"pr76\"\n    pr107 = \"pr107\"\n    pr124 = \"pr124\"\n    pr136 = \"pr136\"\n    pr144 = \"pr144\"\n    pr152 = \"pr152\"\n    pr226 = \"pr226\"\n    pr264 = \"pr264\"\n    pr299 = \"pr299\"\n    pr439 = \"pr439\"\n    pr1002 = \"pr1002\"\n    pr2392 = \"pr2392\"\n    rat99 = \"rat99\"\n    rat195 = \"rat195\"\n    rat575 = \"rat575\"\n    rat783 = \"rat783\"\n    rd100 = \"rd100\"\n    rd400 = \"rd400\"\n    rl1304 = \"rl1304\"\n    rl1323 = \"rl1323\"\n    rl1889 = \"rl1889\"\n    rl5915 = \"rl5915\"\n    rl5934 = \"rl5934\"\n    rl11849 = \"rl11849\"\n    si175 = \"si175\"\n    si535 = \"si535\"\n    si1032 = \"si1032\"\n    st70 = \"st70\"\n    swiss42 = \"swiss42\"\n    ts225 = \"ts225\"\n    tsp225 = \"tsp225\"\n    u159 = \"u159\"\n    u574 = \"u574\"\n    u724 = \"u724\"\n    u1060 = \"u1060\"\n    u1432 = \"u1432\"\n    u1817 = \"u1817\"\n    u2152 = \"u2152\"\n    u2319 = \"u2319\"\n    ulysses16 = \"ulysses16\"\n    ulysses22 = \"ulysses22\"\n    usa13509 = \"usa13509\"\n    vm1084 = \"vm1084\"\n    vm1748 = \"vm1748\"\n</code></pre>"},{"location":"api/#tspwplib.LondonaqGraphName","title":"<code>LondonaqGraphName</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Names of graphs with London air quality forecasts</p> Source code in <code>tspwplib/types.py</code> <pre><code>class LondonaqGraphName(StrEnumMixin, str, Enum):\n    \"\"\"Names of graphs with London air quality forecasts\"\"\"\n\n    laqkxA = \"laqkxA\"\n    laqtinyA = \"laqtinyA\"\n    laqbbA = \"laqbbA\"\n    laqidA = \"laqidA\"\n    laqwsA = \"laqwsA\"\n</code></pre>"},{"location":"api/#tspwplib.LondonaqLocation","title":"<code>LondonaqLocation</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Names of locations that the London air quality graph is centered upon</p> Source code in <code>tspwplib/types.py</code> <pre><code>class LondonaqLocation(StrEnumMixin, str, Enum):\n    \"\"\"Names of locations that the London air quality graph is centered upon\"\"\"\n\n    bb = \"Big Ben\"\n    kx = \"King's Cross\"\n    tiny = \"Camden Town\"\n    id = \"Isle of Dogs\"\n    ws = \"Wembley Stadium\"\n</code></pre>"},{"location":"api/#tspwplib.LondonaqLocationShort","title":"<code>LondonaqLocationShort</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Short codes for londonaq locations</p> Source code in <code>tspwplib/types.py</code> <pre><code>class LondonaqLocationShort(StrEnumMixin, str, Enum):\n    \"\"\"Short codes for londonaq locations\"\"\"\n\n    bb = \"bb\"\n    kx = \"kx\"\n    tiny = \"tiny\"\n    id = \"id\"\n    ws = \"ws\"\n</code></pre>"},{"location":"api/#tspwplib.LondonaqTimestamp","title":"<code>LondonaqTimestamp</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Timestamps of the forecasts for London air quality forecasts</p> Source code in <code>tspwplib/types.py</code> <pre><code>class LondonaqTimestamp(Enum):\n    \"\"\"Timestamps of the forecasts for London air quality forecasts\"\"\"\n\n    A = datetime.datetime(2021, 10, 13, 8, 0, 0, tzinfo=datetime.UTC)  # 9am BST\n</code></pre>"},{"location":"api/#tspwplib.LondonaqTimestampId","title":"<code>LondonaqTimestampId</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Timestamp IDs for CLI</p> Source code in <code>tspwplib/types.py</code> <pre><code>class LondonaqTimestampId(StrEnumMixin, str, Enum):\n    \"\"\"Timestamp IDs for CLI\"\"\"\n\n    A = \"A\"\n</code></pre>"},{"location":"api/#tspwplib.NotSimpleCycleException","title":"<code>NotSimpleCycleException</code>","text":"<p>             Bases: <code>NotSimpleException</code></p> <p>The walk was not a simple cycle</p> Source code in <code>tspwplib/exception.py</code> <pre><code>class NotSimpleCycleException(NotSimpleException):\n    \"\"\"The walk was not a simple cycle\"\"\"\n</code></pre>"},{"location":"api/#tspwplib.NotSimpleException","title":"<code>NotSimpleException</code>","text":"<p>             Bases: <code>NetworkXException</code></p> <p>A path, cycle or walk is not simple</p> Source code in <code>tspwplib/exception.py</code> <pre><code>class NotSimpleException(ex.NetworkXException):\n    \"\"\"A path, cycle or walk is not simple\"\"\"\n</code></pre>"},{"location":"api/#tspwplib.NotSimplePathException","title":"<code>NotSimplePathException</code>","text":"<p>             Bases: <code>NotSimpleException</code></p> <p>The walk was not a simple path</p> Source code in <code>tspwplib/exception.py</code> <pre><code>class NotSimplePathException(NotSimpleException):\n    \"\"\"The walk was not a simple path\"\"\"\n</code></pre>"},{"location":"api/#tspwplib.OptimalSolutionTSP","title":"<code>OptimalSolutionTSP</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>Value of optimal solutions to TSP instances</p> Source code in <code>tspwplib/types.py</code> <pre><code>class OptimalSolutionTSP(IntEnum):\n    \"\"\"Value of optimal solutions to TSP instances\"\"\"\n\n    a280 = 2579\n    ali535 = 202339\n    att48 = 10628\n    att532 = 27686\n    bayg29 = 1610\n    bays29 = 2020\n    berlin52 = 7542\n    bier127 = 118282\n    brazil58 = 25395\n    brd14051 = 469385\n    brg180 = 1950\n    burma14 = 3323\n    ch130 = 6110\n    ch150 = 6528\n    d198 = 15780\n    d493 = 35002\n    d657 = 48912\n    d1291 = 50801\n    d1655 = 62128\n    d2103 = 80450\n    d15112 = 1573084\n    d18512 = 645238\n    dantzig42 = 699\n    dsj1000 = 18659688  # (EUC_2D)\n    # dsj1000 = 18660188 # (CEIL_2D)    # NOTE breaks keys\n    eil51 = 426\n    eil76 = 538\n    eil101 = 629\n    fl417 = 11861\n    fl1400 = 20127\n    fl1577 = 22249\n    fl3795 = 28772\n    fnl4461 = 182566\n    fri26 = 937\n    gil262 = 2378\n    gr17 = 2085\n    gr21 = 2707\n    gr24 = 1272\n    gr48 = 5046\n    gr96 = 55209\n    gr120 = 6942\n    gr137 = 69853\n    gr202 = 40160\n    gr229 = 134602\n    gr431 = 171414\n    gr666 = 294358\n    hk48 = 11461\n    kroA100 = 21282\n    kroB100 = 22141\n    kroC100 = 20749\n    kroD100 = 21294\n    kroE100 = 22068\n    kroA150 = 26524\n    kroB150 = 26130\n    kroA200 = 29368\n    kroB200 = 29437\n    lin105 = 14379\n    lin318 = 42029\n    linhp318 = 41345\n    nrw1379 = 56638\n    p654 = 34643\n    pa561 = 2763\n    pcb442 = 50778\n    pcb1173 = 56892\n    pcb3038 = 137694\n    pla7397 = 23260728\n    pla33810 = 66048945\n    pla85900 = 142382641\n    pr76 = 108159\n    pr107 = 44303\n    pr124 = 59030\n    pr136 = 96772\n    pr144 = 58537\n    pr152 = 73682\n    pr226 = 80369\n    pr264 = 49135\n    pr299 = 48191\n    pr439 = 107217\n    pr1002 = 259045\n    pr2392 = 378032\n    rat99 = 1211\n    rat195 = 2323\n    rat575 = 6773\n    rat783 = 8806\n    rd100 = 7910\n    rd400 = 15281\n    rl1304 = 252948\n    rl1323 = 270199\n    rl1889 = 316536\n    rl5915 = 565530\n    rl5934 = 556045\n    rl11849 = 923288\n    si175 = 21407\n    si535 = 48450\n    si1032 = 92650\n    st70 = 675\n    swiss42 = 1273\n    ts225 = 126643\n    tsp225 = 3916\n    u159 = 42080\n    u574 = 36905\n    u724 = 41910\n    u1060 = 224094\n    u1432 = 152970\n    u1817 = 57201\n    u2152 = 64253\n    u2319 = 234256\n    ulysses16 = 6859\n    ulysses22 = 7013\n    usa13509 = 19982859\n    vm1084 = 239297\n    vm1748 = 336556\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem","title":"<code>ProfitsProblem</code>","text":"<p>             Bases: <code>StandardProblem</code></p> <p>TSP with Profits Problem</p> Source code in <code>tspwplib/problem.py</code> <pre><code>class ProfitsProblem(tsplib95.models.StandardProblem):\n    \"\"\"TSP with Profits Problem\"\"\"\n\n    # overwrite edge data to fix bugs\n    edge_data = TempEdgeDataField(\"EDGE_DATA\")\n    # Maximum distance of the total route in a OP.\n    cost_limit = tsplib95.fields.IntegerField(\"COST_LIMIT\")\n    # The scores of the nodes of a OP are given in the form (per line)\n    node_score = tsplib95.fields.DemandsField(\"NODE_SCORE_SECTION\")\n    # The optimal solution to the TSP\n    tspsol = tsplib95.fields.IntegerField(\"TSPSOL\")\n\n    def __init__(self, special=None, **data):\n        super().__init__(special=special, **data)\n\n    def __set_edge_attributes(self, graph: nx.Graph, names: VertexLookup) -&gt; None:\n        \"\"\"Set edge attributes\"\"\"\n        # add every edge with some associated metadata\n        for edge in self.get_edges():\n            cost: int = self.get_weight(edge[0], edge[1])\n            # pylint: disable=unsupported-membership-test\n            # is_fixed: bool = (u, v) in self.fixed_edges\n            graph.add_edge(names[edge[0]], names[edge[1]], cost=cost)\n\n    def __set_graph_attributes(self, graph: nx.Graph) -&gt; None:\n        \"\"\"Set attributes of the graph such as the name\"\"\"\n        graph.graph[\"name\"] = self.name\n        graph.graph[\"comment\"] = self.comment\n        graph.graph[\"type\"] = self.type\n        graph.graph[\"dimension\"] = self.dimension\n        graph.graph[\"capacity\"] = self.capacity\n        graph.graph[\"root\"] = self.get_root_vertex()\n\n    def __set_node_attributes(self, graph: nx.Graph, names: VertexLookup) -&gt; None:\n        \"\"\"Add node attributes\"\"\"\n        node_score = self.get_node_score()\n        for vertex in list(self.get_nodes()):\n            # pylint: disable=unsupported-membership-test,no-member\n            is_depot = vertex in self.depots\n            graph.add_node(\n                names[vertex],\n                prize=node_score[vertex],\n                is_depot=is_depot,\n            )\n            demand: int = self.demands.get(vertex)\n            display = self.display_data.get(vertex)\n            if not demand is None:\n                graph[vertex][\"demand\"] = demand\n            if not display is None:\n                graph[vertex][\"display\"] = display\n            if self.node_coords:\n                coord = self.node_coords.get(vertex)\n                graph.nodes[names[vertex]][\"x\"] = coord[0]\n                graph.nodes[names[vertex]][\"y\"] = coord[1]\n\n    def get_weight(self, start: int, end: int) -&gt; int:\n        \"\"\"Return the weight of the edge between start and end.\n\n        This method provides a single way to obtain edge weights regardless of\n        whether the problem uses an explicit matrix or a distance function.\n\n        Args:\n            start: starting node index\n            end: ending node index\n\n        Returns:\n            Weight of edge\n\n        Notes:\n            Over-rides euclidean weight to ensure the costs are metric\n        \"\"\"\n        if self.edge_weight_type == EdgeWeightType.EUC_2D:\n            return tsplib95.distances.euclidean(\n                self.node_coords.get(start), self.node_coords.get(end), round=math.ceil\n            )\n        return super().get_weight(start, end)\n\n    def get_graph(self, normalize: bool = False) -&gt; nx.Graph:\n        \"\"\"Return a networkx graph instance representing the problem.\n\n        Args:\n            normalize: rename nodes to be zero-indexed\n        \"\"\"\n        # directed graphs are fundamentally different\n        graph: nx.Graph = nx.Graph() if self.is_symmetric() else nx.DiGraph()\n\n        # set up a map from original node name to new node name\n        nodes: List[Vertex] = list(self.get_nodes())\n        if normalize:\n            names = {n: i for i, n in enumerate(nodes)}\n        else:\n            names = {n: n for n in nodes}\n\n        self.__set_node_attributes(graph, names)\n        self.__set_edge_attributes(graph, names)\n\n        # add basic graph metadata\n        self.__set_graph_attributes(graph)\n        return graph\n\n    def get_total_prize(self) -&gt; int:\n        \"\"\"Get the sum of prize over all vertices\n\n        Returns:\n            Total prize\n        \"\"\"\n        # pylint: disable=no-member\n        return sum([value for _, value in self.get_node_score().items()])\n\n    def get_quota(self, alpha: int) -&gt; int:\n        \"\"\"The quota is alpha percent of the total prize\n\n        Args:\n            alpha: Percent of the total prize\n\n        Returns:\n            quota\n        \"\"\"\n        return get_quota_from_alpha(alpha, self.get_total_prize())\n\n    def number_of_nodes(self) -&gt; int:\n        \"\"\"Get the number of nodes in the problem\n\n        Returns:\n            Number of nodes in graph\n        \"\"\"\n        return len(list(self.get_nodes()))\n\n    def get_cost_limit(self) -&gt; int:\n        \"\"\"Get the cost limit for a TSP with Profits problem\n\n        Returns:\n            Cost limit\n        \"\"\"\n        return self.cost_limit\n\n    def get_node_score(self) -&gt; VertexLookup:\n        \"\"\"Get the node scores (profits)\n\n        Returns:\n            Mapping from node to node score (profit)\n        \"\"\"\n        score_dict: VertexLookup = {}\n        for key, value in self.node_score.items():  # pylint: disable=no-member\n            score_dict[key] = value\n        return score_dict\n\n    def get_tsp_optimal_value(self) -&gt; int:\n        \"\"\"Get the value of the optimal solution to TSP\n\n        Returns:\n            TSP optimal value\n        \"\"\"\n        return self.tspsol\n\n    def get_root_vertex(self, normalize: bool = False) -&gt; Vertex:\n        \"\"\"Get the root vertex\n\n        Args:\n            normalize: If true, vertices start at index 0\n\n        Returns:\n            The first depot in the list\n\n        Raises:\n            ValueError: If the list of depots is empty\n        \"\"\"\n        nodes: List[Vertex] = list(self.get_nodes())\n        if normalize:\n            names = {n: i for i, n in enumerate(nodes)}\n        else:\n            names = {n: n for n in nodes}\n        try:\n            # pylint: disable=unsubscriptable-object\n            return names[self.depots[0]]\n        except KeyError as key_error:\n            raise ValueError(\"The list of depots is empty\") from key_error\n\n    # pylint: disable=arguments-differ\n    def get_edges(self, normalize: bool = False) -&gt; EdgeList:\n        \"\"\"Get a list of edges in the graph\n\n        Args:\n            normalize: If true use the normalized vertex ids\n\n        Returns:\n            List of edges in the graph\n        \"\"\"\n        if normalize:\n            raise NotImplementedError(\"Normalizing edges not yet implemented\")\n        return list(super().get_edges())\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.__set_edge_attributes","title":"<code>__set_edge_attributes(graph, names)</code>","text":"<p>Set edge attributes</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def __set_edge_attributes(self, graph: nx.Graph, names: VertexLookup) -&gt; None:\n    \"\"\"Set edge attributes\"\"\"\n    # add every edge with some associated metadata\n    for edge in self.get_edges():\n        cost: int = self.get_weight(edge[0], edge[1])\n        # pylint: disable=unsupported-membership-test\n        # is_fixed: bool = (u, v) in self.fixed_edges\n        graph.add_edge(names[edge[0]], names[edge[1]], cost=cost)\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.__set_graph_attributes","title":"<code>__set_graph_attributes(graph)</code>","text":"<p>Set attributes of the graph such as the name</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def __set_graph_attributes(self, graph: nx.Graph) -&gt; None:\n    \"\"\"Set attributes of the graph such as the name\"\"\"\n    graph.graph[\"name\"] = self.name\n    graph.graph[\"comment\"] = self.comment\n    graph.graph[\"type\"] = self.type\n    graph.graph[\"dimension\"] = self.dimension\n    graph.graph[\"capacity\"] = self.capacity\n    graph.graph[\"root\"] = self.get_root_vertex()\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.__set_node_attributes","title":"<code>__set_node_attributes(graph, names)</code>","text":"<p>Add node attributes</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def __set_node_attributes(self, graph: nx.Graph, names: VertexLookup) -&gt; None:\n    \"\"\"Add node attributes\"\"\"\n    node_score = self.get_node_score()\n    for vertex in list(self.get_nodes()):\n        # pylint: disable=unsupported-membership-test,no-member\n        is_depot = vertex in self.depots\n        graph.add_node(\n            names[vertex],\n            prize=node_score[vertex],\n            is_depot=is_depot,\n        )\n        demand: int = self.demands.get(vertex)\n        display = self.display_data.get(vertex)\n        if not demand is None:\n            graph[vertex][\"demand\"] = demand\n        if not display is None:\n            graph[vertex][\"display\"] = display\n        if self.node_coords:\n            coord = self.node_coords.get(vertex)\n            graph.nodes[names[vertex]][\"x\"] = coord[0]\n            graph.nodes[names[vertex]][\"y\"] = coord[1]\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_cost_limit","title":"<code>get_cost_limit()</code>","text":"<p>Get the cost limit for a TSP with Profits problem</p> <p>Returns:</p> Type Description <code>int</code> <p>Cost limit</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_cost_limit(self) -&gt; int:\n    \"\"\"Get the cost limit for a TSP with Profits problem\n\n    Returns:\n        Cost limit\n    \"\"\"\n    return self.cost_limit\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_edges","title":"<code>get_edges(normalize=False)</code>","text":"<p>Get a list of edges in the graph</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>If true use the normalized vertex ids</p> <code>False</code> <p>Returns:</p> Type Description <code>EdgeList</code> <p>List of edges in the graph</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_edges(self, normalize: bool = False) -&gt; EdgeList:\n    \"\"\"Get a list of edges in the graph\n\n    Args:\n        normalize: If true use the normalized vertex ids\n\n    Returns:\n        List of edges in the graph\n    \"\"\"\n    if normalize:\n        raise NotImplementedError(\"Normalizing edges not yet implemented\")\n    return list(super().get_edges())\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_graph","title":"<code>get_graph(normalize=False)</code>","text":"<p>Return a networkx graph instance representing the problem.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>rename nodes to be zero-indexed</p> <code>False</code> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_graph(self, normalize: bool = False) -&gt; nx.Graph:\n    \"\"\"Return a networkx graph instance representing the problem.\n\n    Args:\n        normalize: rename nodes to be zero-indexed\n    \"\"\"\n    # directed graphs are fundamentally different\n    graph: nx.Graph = nx.Graph() if self.is_symmetric() else nx.DiGraph()\n\n    # set up a map from original node name to new node name\n    nodes: List[Vertex] = list(self.get_nodes())\n    if normalize:\n        names = {n: i for i, n in enumerate(nodes)}\n    else:\n        names = {n: n for n in nodes}\n\n    self.__set_node_attributes(graph, names)\n    self.__set_edge_attributes(graph, names)\n\n    # add basic graph metadata\n    self.__set_graph_attributes(graph)\n    return graph\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_node_score","title":"<code>get_node_score()</code>","text":"<p>Get the node scores (profits)</p> <p>Returns:</p> Type Description <code>VertexLookup</code> <p>Mapping from node to node score (profit)</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_node_score(self) -&gt; VertexLookup:\n    \"\"\"Get the node scores (profits)\n\n    Returns:\n        Mapping from node to node score (profit)\n    \"\"\"\n    score_dict: VertexLookup = {}\n    for key, value in self.node_score.items():  # pylint: disable=no-member\n        score_dict[key] = value\n    return score_dict\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_quota","title":"<code>get_quota(alpha)</code>","text":"<p>The quota is alpha percent of the total prize</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>int</code> <p>Percent of the total prize</p> required <p>Returns:</p> Type Description <code>int</code> <p>quota</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_quota(self, alpha: int) -&gt; int:\n    \"\"\"The quota is alpha percent of the total prize\n\n    Args:\n        alpha: Percent of the total prize\n\n    Returns:\n        quota\n    \"\"\"\n    return get_quota_from_alpha(alpha, self.get_total_prize())\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_root_vertex","title":"<code>get_root_vertex(normalize=False)</code>","text":"<p>Get the root vertex</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>If true, vertices start at index 0</p> <code>False</code> <p>Returns:</p> Type Description <code>Vertex</code> <p>The first depot in the list</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the list of depots is empty</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_root_vertex(self, normalize: bool = False) -&gt; Vertex:\n    \"\"\"Get the root vertex\n\n    Args:\n        normalize: If true, vertices start at index 0\n\n    Returns:\n        The first depot in the list\n\n    Raises:\n        ValueError: If the list of depots is empty\n    \"\"\"\n    nodes: List[Vertex] = list(self.get_nodes())\n    if normalize:\n        names = {n: i for i, n in enumerate(nodes)}\n    else:\n        names = {n: n for n in nodes}\n    try:\n        # pylint: disable=unsubscriptable-object\n        return names[self.depots[0]]\n    except KeyError as key_error:\n        raise ValueError(\"The list of depots is empty\") from key_error\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_total_prize","title":"<code>get_total_prize()</code>","text":"<p>Get the sum of prize over all vertices</p> <p>Returns:</p> Type Description <code>int</code> <p>Total prize</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_total_prize(self) -&gt; int:\n    \"\"\"Get the sum of prize over all vertices\n\n    Returns:\n        Total prize\n    \"\"\"\n    # pylint: disable=no-member\n    return sum([value for _, value in self.get_node_score().items()])\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_tsp_optimal_value","title":"<code>get_tsp_optimal_value()</code>","text":"<p>Get the value of the optimal solution to TSP</p> <p>Returns:</p> Type Description <code>int</code> <p>TSP optimal value</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_tsp_optimal_value(self) -&gt; int:\n    \"\"\"Get the value of the optimal solution to TSP\n\n    Returns:\n        TSP optimal value\n    \"\"\"\n    return self.tspsol\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.get_weight","title":"<code>get_weight(start, end)</code>","text":"<p>Return the weight of the edge between start and end.</p> <p>This method provides a single way to obtain edge weights regardless of whether the problem uses an explicit matrix or a distance function.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>starting node index</p> required <code>end</code> <code>int</code> <p>ending node index</p> required <p>Returns:</p> Type Description <code>int</code> <p>Weight of edge</p> Notes <p>Over-rides euclidean weight to ensure the costs are metric</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_weight(self, start: int, end: int) -&gt; int:\n    \"\"\"Return the weight of the edge between start and end.\n\n    This method provides a single way to obtain edge weights regardless of\n    whether the problem uses an explicit matrix or a distance function.\n\n    Args:\n        start: starting node index\n        end: ending node index\n\n    Returns:\n        Weight of edge\n\n    Notes:\n        Over-rides euclidean weight to ensure the costs are metric\n    \"\"\"\n    if self.edge_weight_type == EdgeWeightType.EUC_2D:\n        return tsplib95.distances.euclidean(\n            self.node_coords.get(start), self.node_coords.get(end), round=math.ceil\n        )\n    return super().get_weight(start, end)\n</code></pre>"},{"location":"api/#tspwplib.ProfitsProblem.number_of_nodes","title":"<code>number_of_nodes()</code>","text":"<p>Get the number of nodes in the problem</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of nodes in graph</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def number_of_nodes(self) -&gt; int:\n    \"\"\"Get the number of nodes in the problem\n\n    Returns:\n        Number of nodes in graph\n    \"\"\"\n    return len(list(self.get_nodes()))\n</code></pre>"},{"location":"api/#tspwplib.VertexFunctionName","title":"<code>VertexFunctionName</code>","text":"<p>             Bases: <code>StrEnumMixin</code>, <code>str</code>, <code>Enum</code></p> <p>Valid names of functions on vertices</p> Source code in <code>tspwplib/types.py</code> <pre><code>class VertexFunctionName(StrEnumMixin, str, Enum):\n    \"\"\"Valid names of functions on vertices\"\"\"\n\n    demand = \"demand\"\n    prize = \"prize\"\n</code></pre>"},{"location":"api/#tspwplib.asymmetric_from_directed","title":"<code>asymmetric_from_directed(G)</code>","text":"<p>Create asymmetric directed graph from directed graph</p> <p>Split every node u two nodes u1 and u2. We add a directed arc between u1 and u2. Any previous inward edge v-&gt;u is now v-&gt;u1 and any outward edge from u is now u2-&gt;v.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>DiGraph</code> <p>Directed graph</p> required <p>Returns:</p> Type Description <code>DiGraph</code> <p>Directed asymmetric graph</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def asymmetric_from_directed(G: nx.DiGraph) -&gt; nx.DiGraph:\n    \"\"\"Create asymmetric directed graph from directed graph\n\n    Split every node u two nodes u1 and u2.\n    We add a directed arc between u1 and u2.\n    Any previous inward edge v-&gt;u is now v-&gt;u1 and any outward edge from u is now u2-&gt;v.\n\n    Args:\n        G: Directed graph\n\n    Returns:\n        Directed asymmetric graph\n    \"\"\"\n    asymmetric_graph = nx.DiGraph()\n    nodes_for_adding: List[Tuple[Vertex, Dict]] = []\n    edges_for_adding: List[Tuple[Vertex, Vertex, Dict]] = []\n    # deepcopy when not a view\n    asymmetric_graph.graph.update(deepcopy(G.graph))\n\n    # find the id of the biggest vertex\n    biggest_vertex = biggest_vertex_id_from_graph(G)\n\n    for vertex, data in G.nodes(data=True):\n        # split the vertex into two\n        head = split_head(biggest_vertex, vertex)\n        tail = split_tail(biggest_vertex, vertex)\n\n        # the data is copied to both vertices\n        tail_data = data.copy()\n        head_data = data.copy()\n\n        # split the value of the prize\n        prize: int = data.get(VertexFunctionName.prize, 0)\n        tail_data[VertexFunctionName.prize] = tail_prize(prize)\n        head_data[VertexFunctionName.prize] = head_prize(prize)\n\n        # add vertex to asymmetric graph with new data\n        nodes_for_adding.append((head, head_data))\n        nodes_for_adding.append((tail, tail_data))\n\n        # add zero-cost edge from tail to head\n        edge = (tail, head, {EdgeFunctionName.cost.value: 0})\n        edges_for_adding.append(edge)\n\n    for u, v, edge_data in G.edges(data=True):\n        # add edge from head of u to tail of v with data\n        u_head = split_head(biggest_vertex, u)\n        v_tail = split_tail(biggest_vertex, v)\n        edge_uv = (u_head, v_tail, edge_data)\n        edges_for_adding.append(edge_uv)\n\n    # add nodes and edges then return graph\n    asymmetric_graph.add_nodes_from(nodes_for_adding)\n    asymmetric_graph.add_edges_from(edges_for_adding)\n    return asymmetric_graph\n</code></pre>"},{"location":"api/#tspwplib.asymmetric_from_undirected","title":"<code>asymmetric_from_undirected(G)</code>","text":"<p>Create asymmetric directed graph from undirected graph</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Undirected graph</p> required <p>Returns:</p> Type Description <code>DiGraph</code> <p>Directed asymmetric graph</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def asymmetric_from_undirected(G: nx.Graph) -&gt; nx.DiGraph:\n    \"\"\"Create asymmetric directed graph from undirected graph\n\n    Args:\n        G: Undirected graph\n\n    Returns:\n        Directed asymmetric graph\n    \"\"\"\n    directed_graph = G.to_directed()\n    return asymmetric_from_directed(directed_graph)\n</code></pre>"},{"location":"api/#tspwplib.biggest_vertex_id_from_graph","title":"<code>biggest_vertex_id_from_graph(G)</code>","text":"<p>Return the vertex with the largest integer id</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph</p> required <p>Returns:</p> Type Description <code>Vertex</code> <p>Vertex with biggest id</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def biggest_vertex_id_from_graph(G: nx.Graph) -&gt; Vertex:\n    \"\"\"Return the vertex with the largest integer id\n\n    Args:\n        G: Graph\n\n    Returns:\n        Vertex with biggest id\n    \"\"\"\n    return max(G)\n</code></pre>"},{"location":"api/#tspwplib.build_path_to_londonaq_instance","title":"<code>build_path_to_londonaq_instance(londonaq_root, name)</code>","text":"<p>Build a filepath to a londonaq instance</p> <p>Parameters:</p> Name Type Description Default <code>londonaq_root</code> <code>Path</code> <p>Root directory of the londonaq dataset</p> required <code>name</code> <code>LondonaqGraphName</code> <p>Londonaq graph name</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Filepath to the londonaq txt</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def build_path_to_londonaq_instance(\n    londonaq_root: Path,\n    name: LondonaqGraphName,\n) -&gt; Path:\n    \"\"\"Build a filepath to a londonaq instance\n\n    Args:\n        londonaq_root: Root directory of the londonaq dataset\n        name: Londonaq graph name\n\n    Returns:\n        Filepath to the londonaq txt\n    \"\"\"\n    return londonaq_root / name.value / f\"{name.value}.txt\"\n</code></pre>"},{"location":"api/#tspwplib.build_path_to_londonaq_yaml","title":"<code>build_path_to_londonaq_yaml(londonaq_root, name)</code>","text":"<p>Build a filepath to the londonaq yaml file</p> <p>Parameters:</p> Name Type Description Default <code>londonaq_root</code> <code>Path</code> <p>Root directory of the londonaq dataset</p> required <code>name</code> <code>LondonaqGraphName</code> <p>Londonaq graph name</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Filepath to the londonaq yaml file</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def build_path_to_londonaq_yaml(londonaq_root: Path, name: LondonaqGraphName) -&gt; Path:\n    \"\"\"Build a filepath to the londonaq yaml file\n\n    Args:\n        londonaq_root: Root directory of the londonaq dataset\n        name: Londonaq graph name\n\n    Returns:\n        Filepath to the londonaq yaml file\n    \"\"\"\n    return londonaq_root / name.value / f\"{name.value}.yaml\"\n</code></pre>"},{"location":"api/#tspwplib.build_path_to_oplib_instance","title":"<code>build_path_to_oplib_instance(oplib_root, generation, name, alpha=Alpha.fifty.value)</code>","text":"<p>Build a filepath to a oplib instance</p> <p>Parameters:</p> Name Type Description Default <code>oplib_root</code> <code>Path</code> <p>The directory of the clones oplib</p> required <code>generation</code> <code>Generation</code> <p>Generation of OPLib instance</p> required <code>name</code> <code>GraphName</code> <p>Graph instance name</p> required <code>alpha</code> <code>int</code> <p>Percent of the total cost to set the cost limit to. Not useful for instances of Prize-collecting TSPs. Default is 50. Note if you change to a different value, make sure the file exists</p> <code>value</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the OPLib instance</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def build_path_to_oplib_instance(\n    oplib_root: Path,\n    generation: Generation,\n    name: GraphName,\n    alpha: int = Alpha.fifty.value,\n) -&gt; Path:\n    \"\"\"Build a filepath to a oplib instance\n\n    Args:\n        oplib_root: The directory of the clones oplib\n        generation: Generation of OPLib instance\n        name: Graph instance name\n        alpha: Percent of the total cost to set the cost limit to.\n            Not useful for instances of Prize-collecting TSPs.\n            Default is 50.\n            Note if you change to a different value, make sure the file exists\n\n    Returns:\n        Path to the OPLib instance\n    \"\"\"\n    filename: str = name + \"-\" + generation.value + \"-\" + str(alpha) + \".oplib\"\n    return oplib_root / \"instances\" / generation.value / filename\n</code></pre>"},{"location":"api/#tspwplib.build_path_to_tsplib_instance","title":"<code>build_path_to_tsplib_instance(tsplib_root, name)</code>","text":"<p>Build a filepath to a tsplib instance</p> <p>Parameters:</p> Name Type Description Default <code>tsplib_root</code> <code>Path</code> <p>Directory containing TSP txt instances</p> required <code>name</code> <code>GraphName</code> <p>Name of the instance</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Filepath to the TSP instance</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def build_path_to_tsplib_instance(tsplib_root: Path, name: GraphName) -&gt; Path:\n    \"\"\"Build a filepath to a tsplib instance\n\n    Args:\n        tsplib_root: Directory containing TSP txt instances\n        name: Name of the instance\n\n    Returns:\n        Filepath to the TSP instance\n    \"\"\"\n    filename = name.value + \".tsp\"\n    return tsplib_root / filename\n</code></pre>"},{"location":"api/#tspwplib.edge_list_from_walk","title":"<code>edge_list_from_walk(walk)</code>","text":"<p>Get ordered list of edges from an ordered list of vertices</p> <p>Parameters:</p> Name Type Description Default <code>walk</code> <code>VertexList</code> <p>Ordered list of vertices that represent a walk in the graph</p> required <p>Returns:</p> Type Description <code>EdgeList</code> <p>List of edges in the same order as the walk</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def edge_list_from_walk(walk: VertexList) -&gt; EdgeList:\n    \"\"\"Get ordered list of edges from an ordered list of vertices\n\n    Args:\n        walk: Ordered list of vertices that represent a walk in the graph\n\n    Returns:\n        List of edges in the same order as the walk\n    \"\"\"\n    edge_list: EdgeList = []\n    if len(walk) &lt;= 1:\n        return edge_list\n    for i in range(len(walk) - 1):\n        vertex = walk[i]\n        next_vertex = walk[i + 1]\n        edge_list.append((vertex, next_vertex))\n    return edge_list\n</code></pre>"},{"location":"api/#tspwplib.get_original_from_split_vertex","title":"<code>get_original_from_split_vertex(biggest_vertex, split_vertex)</code>","text":"<p>Return the original vertex id given a split vertex (may be head or tail)</p> <p>Parameters:</p> Name Type Description Default <code>biggest_vertex</code> <code>Vertex</code> <p>The vertex with the biggest id in the original graph</p> required <code>split_vertex</code> <code>Vertex</code> <p>A split vertex in asymmetric graph</p> required <p>Returns:</p> Type Description <code>Vertex</code> <p>ID of the vertex in the original graph</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def get_original_from_split_vertex(\n    biggest_vertex: Vertex, split_vertex: Vertex\n) -&gt; Vertex:\n    \"\"\"Return the original vertex id given a split vertex (may be head or tail)\n\n    Args:\n        biggest_vertex: The vertex with the biggest id in the original graph\n        split_vertex: A split vertex in asymmetric graph\n\n    Returns:\n        ID of the vertex in the original graph\n    \"\"\"\n    if is_vertex_split_head(biggest_vertex, split_vertex):\n        return split_vertex - 2 * (biggest_vertex + 1)\n    # else split tail\n    return split_vertex - biggest_vertex - 1\n</code></pre>"},{"location":"api/#tspwplib.get_original_path_from_split_path","title":"<code>get_original_path_from_split_path(biggest_vertex, split_path)</code>","text":"<p>Get the path in the original graph given a path of split vertices in the asymmetric graph</p> <p>Parameters:</p> Name Type Description Default <code>biggest_vertex</code> <code>Vertex</code> <p>The vertex with the biggest id in the original graph</p> required <code>split_path</code> <code>VertexList</code> <p>A path of split vertices in the asymmetric directed graph</p> required <p>Returns:</p> Type Description <code>VertexList</code> <p>A path of vertices in the original graph</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def get_original_path_from_split_path(\n    biggest_vertex: Vertex, split_path: VertexList\n) -&gt; VertexList:\n    \"\"\"Get the path in the original graph given a path of split vertices in the asymmetric graph\n\n    Args:\n        biggest_vertex: The vertex with the biggest id in the original graph\n        split_path: A path of split vertices in the asymmetric directed graph\n\n    Returns:\n        A path of vertices in the original graph\n    \"\"\"\n    original_path = []\n    previous_vertex = -1\n    for split_vertex in split_path:\n        original_vertex = get_original_from_split_vertex(biggest_vertex, split_vertex)\n        if is_vertex_split_tail(biggest_vertex, split_vertex):\n            original_path.append(original_vertex)\n        elif (\n            is_vertex_split_head(biggest_vertex, split_vertex)\n            and previous_vertex != original_vertex\n        ):\n            original_path.append(original_vertex)\n        previous_vertex = original_vertex\n    return original_path\n</code></pre>"},{"location":"api/#tspwplib.get_quota_from_alpha","title":"<code>get_quota_from_alpha(alpha, total_prize)</code>","text":"<p>The quota is alpha percent of the total prize</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>int</code> <p>Percent of the total prize</p> required <code>total_prize</code> <code>int</code> <p>Total prize of the graph</p> required <p>Returns:</p> Type Description <code>int</code> <p>quota as an integer</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def get_quota_from_alpha(alpha: int, total_prize: int) -&gt; int:\n    \"\"\"The quota is alpha percent of the total prize\n\n    Args:\n        alpha: Percent of the total prize\n        total_prize: Total prize of the graph\n\n    Returns:\n        quota as an integer\n    \"\"\"\n    if alpha &gt; 100:\n        raise ValueError(\"Cannot have a percent over 100 for alpha\")\n    if alpha &lt; 0:\n        raise ValueError(\"Cannot have a negative percent for alpha\")\n    return int(float(alpha * total_prize) / 100.0)\n</code></pre>"},{"location":"api/#tspwplib.head_prize","title":"<code>head_prize(prize)</code>","text":"<p>Get the prize of the split head</p> <p>Parameters:</p> Name Type Description Default <code>prize</code> <code>int</code> <p>The prize of a vertex</p> required <p>Returns     Split head prize</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def head_prize(prize: int) -&gt; int:\n    \"\"\"Get the prize of the split head\n\n    Args:\n        prize: The prize of a vertex\n\n    Returns\n        Split head prize\n    \"\"\"\n    if prize % 2 == 1:\n        return math.ceil(prize / 2.0)\n    return int(prize / 2)\n</code></pre>"},{"location":"api/#tspwplib.is_complete","title":"<code>is_complete(G)</code>","text":"<p>Check if the graph is complete</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Simple graph</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the graph is complete, false otherwise</p> Note <p>Assumes no self loops</p> Source code in <code>tspwplib/complete.py</code> <pre><code>def is_complete(G: nx.Graph) -&gt; bool:\n    \"\"\"Check if the graph is complete\n\n    Args:\n        G: Simple graph\n\n    Returns:\n        True if the graph is complete, false otherwise\n\n    Note:\n        Assumes no self loops\n    \"\"\"\n    for u in G:\n        for v in G:\n            if not G.has_edge(u, v) and u != v:\n                return False\n    return True\n</code></pre>"},{"location":"api/#tspwplib.is_complete_with_self_loops","title":"<code>is_complete_with_self_loops(G)</code>","text":"<p>Check if the graph is complete, and every vertex has a self loop</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Simple graph</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the graph is complete, false otherwise</p> Source code in <code>tspwplib/complete.py</code> <pre><code>def is_complete_with_self_loops(G: nx.Graph) -&gt; bool:\n    \"\"\"Check if the graph is complete, and every vertex has a self loop\n\n    Args:\n        G: Simple graph\n\n    Returns:\n        True if the graph is complete, false otherwise\n    \"\"\"\n    for u in G:\n        if not G.has_edge(u, u):\n            return False\n    return is_complete(G)\n</code></pre>"},{"location":"api/#tspwplib.is_pctsp_yes_instance","title":"<code>is_pctsp_yes_instance(graph, quota, root_vertex, edge_list)</code>","text":"<p>Returns true if the list of edges is a solution to the instance of the Prize collecting Travelling Salesman Problem.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Undirected graph with cost function on edges and prize function on vertices</p> required <code>quota</code> <code>int</code> <p>The salesman must collect at least the quota in prize money</p> required <code>root_vertex</code> <code>Vertex</code> <p>Start and finish vertex of the tour</p> required <code>edge_list</code> <code>EdgeList</code> <p>Edges in the solution of the instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the total prize of the tour is at least the quota and the tour is a simple</p> <code>bool</code> <p>cycle that starts and ends at the root vertex. False otherwise.</p> Source code in <code>tspwplib/problem.py</code> <pre><code>def is_pctsp_yes_instance(\n    graph: nx.Graph, quota: int, root_vertex: Vertex, edge_list: EdgeList\n) -&gt; bool:\n    \"\"\"Returns true if the list of edges is a solution to the instance\n    of the Prize collecting Travelling Salesman Problem.\n\n    Args:\n        graph: Undirected graph with cost function on edges and prize function on vertices\n        quota: The salesman must collect at least the quota in prize money\n        root_vertex: Start and finish vertex of the tour\n        edge_list: Edges in the solution of the instance\n\n    Returns:\n        True if the total prize of the tour is at least the quota and the tour is a simple\n        cycle that starts and ends at the root vertex. False otherwise.\n    \"\"\"\n    if len(edge_list) &lt; 3:\n        return False\n    walk = walk_from_edge_list(edge_list)\n    vertex_set = set(walk)\n    return (\n        is_simple_cycle(graph, walk)\n        and total_prize(\n            nx.get_node_attributes(graph, VertexFunctionName.prize.value), vertex_set\n        )\n        &gt;= quota\n        and root_vertex == walk[0]\n        and root_vertex == walk[len(walk) - 1]\n    )\n</code></pre>"},{"location":"api/#tspwplib.is_simple_cycle","title":"<code>is_simple_cycle(G, cycle)</code>","text":"<p>Is the cycle simple in the graph?</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>input graph</p> required <code>cycle</code> <code>VertexList</code> <p>Ordered sequence of vertices</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the cycle is simple in the graph</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def is_simple_cycle(G: nx.Graph, cycle: VertexList) -&gt; bool:\n    \"\"\"Is the cycle simple in the graph?\n\n    Args:\n        G: input graph\n        cycle: Ordered sequence of vertices\n\n    Returns:\n        True if the cycle is simple in the graph\n    \"\"\"\n    cycle_length = len(cycle)\n    if cycle_length &lt;= 1:\n        return True\n    return (\n        is_walk(G, cycle)\n        and cycle_length == len(set(cycle)) + 1\n        and cycle[0] == cycle[cycle_length - 1]\n    )\n</code></pre>"},{"location":"api/#tspwplib.is_simple_path","title":"<code>is_simple_path(G, path)</code>","text":"<p>Is the path simple in the graph?</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>input graph</p> required <code>path</code> <code>VertexList</code> <p>Ordered sequence of vertices</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path is simple in the graph</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def is_simple_path(G: nx.Graph, path: VertexList) -&gt; bool:\n    \"\"\"Is the path simple in the graph?\n\n    Args:\n        G: input graph\n        path: Ordered sequence of vertices\n\n    Returns:\n        True if the path is simple in the graph\n    \"\"\"\n    return is_walk(G, path) and len(path) == len(set(path))\n</code></pre>"},{"location":"api/#tspwplib.is_split_vertex_pair","title":"<code>is_split_vertex_pair(biggest_vertex, tail, head)</code>","text":"<p>Does the arc (tail, head) represent a split vertex in the original graph?</p> <p>Parameters:</p> Name Type Description Default <code>biggest_vertex</code> <code>Vertex</code> <p>The vertex with the biggest id in the original graph</p> required <code>tail</code> <code>Vertex</code> <p>Tail of edge in directed graph</p> required <code>head</code> <code>Vertex</code> <p>Head of edge in directed graph</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the arc (tail, head) represents a split vertex in the original graph</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def is_split_vertex_pair(biggest_vertex: Vertex, tail: Vertex, head: Vertex) -&gt; bool:\n    \"\"\"Does the arc (tail, head) represent a split vertex in the original graph?\n\n    Args:\n        biggest_vertex: The vertex with the biggest id in the original graph\n        tail: Tail of edge in directed graph\n        head: Head of edge in directed graph\n\n    Returns:\n        True if the arc (tail, head) represents a split vertex in the original graph\n    \"\"\"\n    return (\n        head - tail == biggest_vertex + 1\n        and is_vertex_split_head(biggest_vertex, head)\n        and is_vertex_split_tail(biggest_vertex, tail)\n    )\n</code></pre>"},{"location":"api/#tspwplib.is_vertex_split_head","title":"<code>is_vertex_split_head(biggest_vertex, split_vertex)</code>","text":"<p>Is the vertex a head in the asymmetric graph?</p> <p>Parameters:</p> Name Type Description Default <code>biggest_vertex</code> <code>Vertex</code> <p>The vertex with the biggest id in the original graph</p> required <code>split_vertex</code> <code>Vertex</code> <p>A potential head of an edge in directed graph</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex is a head</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def is_vertex_split_head(biggest_vertex: Vertex, split_vertex: Vertex) -&gt; bool:\n    \"\"\"Is the vertex a head in the asymmetric graph?\n\n    Args:\n        biggest_vertex: The vertex with the biggest id in the original graph\n        split_vertex: A potential head of an edge in directed graph\n\n    Returns:\n        True if the vertex is a head\n    \"\"\"\n    return 2 * (biggest_vertex + 1) &lt;= split_vertex &lt; 3 * (biggest_vertex + 1)\n</code></pre>"},{"location":"api/#tspwplib.is_vertex_split_tail","title":"<code>is_vertex_split_tail(biggest_vertex, vertex)</code>","text":"<p>Is the vertex a tail in the asymmetric graph?</p> <p>Parameters:</p> Name Type Description Default <code>biggest_vertex</code> <code>Vertex</code> <p>The vertex with the biggest id in the original graph</p> required <code>vertex</code> <code>Vertex</code> <p>A potential tail of an edge in directed graph</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vertex is a tail</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def is_vertex_split_tail(biggest_vertex: Vertex, vertex: Vertex) -&gt; bool:\n    \"\"\"Is the vertex a tail in the asymmetric graph?\n\n    Args:\n        biggest_vertex: The vertex with the biggest id in the original graph\n        vertex: A potential tail of an edge in directed graph\n\n    Returns:\n        True if the vertex is a tail\n    \"\"\"\n    return biggest_vertex + 1 &lt;= vertex &lt; 2 * (biggest_vertex + 1)\n</code></pre>"},{"location":"api/#tspwplib.is_walk","title":"<code>is_walk(G, walk)</code>","text":"<p>Is the walk a sequence of adjacent vertices in the graph?</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>input graph</p> required <code>walk</code> <code>VertexList</code> <p>Ordered sequence of vertices</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all vertices are adjacent in the graph</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def is_walk(G: nx.Graph, walk: VertexList) -&gt; bool:\n    \"\"\"Is the walk a sequence of adjacent vertices in the graph?\n\n    Args:\n        G: input graph\n        walk: Ordered sequence of vertices\n\n    Returns:\n        True if all vertices are adjacent in the graph\n    \"\"\"\n    edge_list = edge_list_from_walk(walk)\n    return all(G.has_edge(edge[0], edge[1]) for edge in edge_list)\n</code></pre>"},{"location":"api/#tspwplib.londonaq_comment","title":"<code>londonaq_comment(location_id, timestamp_id)</code>","text":"<p>Get a comment for a londonaq dataset</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def londonaq_comment(\n    location_id: LondonaqLocation, timestamp_id: LondonaqTimestamp\n) -&gt; str:\n    \"\"\"Get a comment for a londonaq dataset\"\"\"\n    comment = f\"A London air quality dataset starting at {location_id.value}. \"\n    comment += f\"The UTC timestamp for the air quality forecast is {timestamp_id.value.isoformat()}\"\n    return comment\n</code></pre>"},{"location":"api/#tspwplib.londonaq_graph_name","title":"<code>londonaq_graph_name(location_id, timestamp_id)</code>","text":"<p>Get a londonaq graph name</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def londonaq_graph_name(\n    location_id: LondonaqLocation, timestamp_id: LondonaqTimestamp\n) -&gt; LondonaqGraphName:\n    \"\"\"Get a londonaq graph name\"\"\"\n    return LondonaqGraphName[\"laq\" + location_id.name + timestamp_id.name]\n</code></pre>"},{"location":"api/#tspwplib.metricness","title":"<code>metricness(graph, cost_attr='cost')</code>","text":"<p>Measures how metric a cost function is</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Must be undirected, connected and not a tree</p> required <code>cost_attr</code> <code>str</code> <p>Name of cost attribute</p> <code>'cost'</code> <p>Returns:</p> Type Description <code>float</code> <p>If a cost function is metric, return 1.0.</p> <code>float</code> <p>If n-1 edges are metric and the remaining edges are non-metric, return 0.0.</p> <p>Raises:</p> Type Description <code>NotConnectedException</code> <p>If the graph is not connected</p> <code>NoTreesException</code> <p>If the graph is a tree</p> Notes <p>Self loops are ignored from the metricness</p> Source code in <code>tspwplib/metric.py</code> <pre><code>def metricness(graph: nx.Graph, cost_attr: str = \"cost\") -&gt; float:\n    \"\"\"Measures how metric a cost function is\n\n    Args:\n        graph: Must be undirected, connected and not a tree\n        cost_attr: Name of cost attribute\n\n    Returns:\n        If a cost function is metric, return 1.0.\n        If n-1 edges are metric and the remaining edges are non-metric, return 0.0.\n\n    Raises:\n        NotConnectedException: If the graph is not connected\n        NoTreesException: If the graph is a tree\n\n    Notes:\n        Self loops are ignored from the metricness\n    \"\"\"\n    if not nx.is_connected(graph):\n        raise NotConnectedException(\"Make sure your graph is connected\")\n    if nx.is_tree(graph):\n        raise NoTreesException(\"Make sure your graph is not a tree\")\n    path_cost = dict(nx.all_pairs_bellman_ford_path_length(graph, weight=cost_attr))\n    num_metric = 0\n    num_non_metric = 0\n    num_self_loops = 0\n    for (u, v), cost in nx.get_edge_attributes(graph, cost_attr).items():\n        if u == v:\n            num_self_loops += 1\n        elif cost &lt;= path_cost[u][v]:\n            num_metric += 1\n        else:\n            num_non_metric += 1\n    print(num_metric, \"metric edges and\", num_non_metric, \"non metric edges\")\n    numerator = (float)(num_metric - graph.number_of_nodes() + 1)\n    denominator = (float)(\n        graph.number_of_edges() - graph.number_of_nodes() - num_self_loops + 1\n    )\n    return numerator / denominator\n</code></pre>"},{"location":"api/#tspwplib.mst_cost","title":"<code>mst_cost(G, cost_attr='cost')</code>","text":"<p>Find the minimum spanning tree of G. The cost of edges in the tree remains unchanged. The cost of edges not in the tree is equal to the cost of the minimum spanning tree plus the original cost of the edges.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Undirected, simple graph</p> required <code>cost_attr</code> <code>str</code> <p>Name of the cost attribute of edges</p> <code>'cost'</code> <p>Returns     A new cost function</p> Source code in <code>tspwplib/metric.py</code> <pre><code>def mst_cost(G: nx.Graph, cost_attr: str = \"cost\") -&gt; SimpleEdgeFunction:\n    \"\"\"Find the minimum spanning tree of G.\n    The cost of edges in the tree remains unchanged.\n    The cost of edges not in the tree is equal to the cost of the minimum spanning tree\n    plus the original cost of the edges.\n\n    Args:\n        G: Undirected, simple graph\n        cost_attr: Name of the cost attribute of edges\n\n    Returns\n        A new cost function\n    \"\"\"\n    # find the cost of the minimum spanning tree in G\n    T = nx.minimum_spanning_tree(G, weight=cost_attr)\n    tree_cost = dict(nx.all_pairs_bellman_ford_path_length(T, weight=cost_attr))\n\n    # set the cost of the new edges\n    new_cost: SimpleEdgeFunction = {}\n    for (u, v), cost in nx.get_edge_attributes(G, cost_attr).items():\n        if T.has_edge(u, v):\n            new_cost[(u, v)] = cost\n        else:\n            new_cost[(u, v)] = cost + tree_cost[u][v]\n    return new_cost\n</code></pre>"},{"location":"api/#tspwplib.order_edge_list","title":"<code>order_edge_list(unordered_edges)</code>","text":"<p>Given a list of unordered edges, return an ordered edge list such that every two adjacent edge in the list are also adjacent in the input graph.</p> <p>Note that the list of edges should form a simple path or cycle.</p> <p>Parameters:</p> Name Type Description Default <code>unordered_edges</code> <code>EdgeList</code> <p>List of unique edges in no particular order</p> required <p>Returns:</p> Type Description <code>EdgeList</code> <p>List of unique edges that are adjacent in the graph</p> <p>Raises:</p> Type Description <code>NotSimpleException</code> <p>If the list of edges is not a simple path or cycle</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def order_edge_list(unordered_edges: EdgeList) -&gt; EdgeList:\n    \"\"\"Given a list of unordered edges, return an ordered edge list\n    such that every two adjacent edge in the list are also adjacent in\n    the input graph.\n\n    Note that the list of edges should form a simple path or cycle.\n\n    Args:\n        unordered_edges: List of unique edges in no particular order\n\n    Returns:\n        List of unique edges that are adjacent in the graph\n\n    Raises:\n        NotSimpleException: If the list of edges is not a simple path or cycle\n    \"\"\"\n    if not unordered_edges:\n        return []\n    # create a lookup table of the first and second occurence of each vertex in the edge list\n    first_occurence: VertexLookup = {}\n    second_occurence: VertexLookup = {}\n    for i, edge in enumerate(unordered_edges):\n        __add_vertex_to_occurence(first_occurence, second_occurence, edge[0], i)\n        __add_vertex_to_occurence(first_occurence, second_occurence, edge[1], i)\n\n    for u in first_occurence:\n        if u not in second_occurence:\n            message = f\"Vertex {u} does not appear in two edges. Walk must be closed.\"\n            raise NotSimpleCycleException(message)\n\n    # use the lookup tables to place the edges in the correct order in the edge list\n    ordered_edges = []\n    j = 0\n    target_index = -1\n    found_source = False\n    first_vertex = 0\n    for i, edge in enumerate(unordered_edges):\n        u = edge[0]\n        v = edge[1]\n        if not found_source and u not in second_occurence:\n            j = i\n            found_source = True\n        elif found_source and u not in second_occurence:\n            target_index = i\n            break\n        elif not found_source and v not in second_occurence:\n            j = i\n            found_source = True\n            first_vertex = 1\n        elif found_source and v not in second_occurence:\n            target_index = i\n            break\n    prev = unordered_edges[j][first_vertex]\n    visited = [False] * len(unordered_edges)\n\n    for i in range(len(unordered_edges)):\n        edge = unordered_edges[j]\n        if visited[j]:\n            raise NotSimpleException()\n        visited[j] = True\n        u = edge[0]\n        v = edge[1]\n        ordered_edges.append(edge)\n        if j == target_index:\n            break\n\n        # if u == prev then follow v\n        if u == prev and j == first_occurence[v]:\n            j = second_occurence[v]\n            prev = v\n        elif u == prev and j == second_occurence[v]:\n            j = first_occurence[v]\n            prev = v\n        # if v == prev then follow u\n        elif v == prev and j == first_occurence[u]:\n            j = second_occurence[u]\n            prev = u\n        elif v == prev and j == second_occurence[u]:\n            j = first_occurence[u]\n            prev = u\n\n    return ordered_edges\n</code></pre>"},{"location":"api/#tspwplib.remove_self_loops_from_edge_list","title":"<code>remove_self_loops_from_edge_list(edge_list)</code>","text":"<p>Return a new edge list with no self loops</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <code>EdgeList</code> <p>List of edges</p> required <p>Returns:</p> Type Description <code>EdgeList</code> <p>Edge list with no self loops</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def remove_self_loops_from_edge_list(edge_list: EdgeList) -&gt; EdgeList:\n    \"\"\"Return a new edge list with no self loops\n\n    Args:\n        edge_list: List of edges\n\n    Returns:\n        Edge list with no self loops\n    \"\"\"\n    return [edge for edge in edge_list if edge[0] != edge[1]]\n</code></pre>"},{"location":"api/#tspwplib.rename_edge_attributes","title":"<code>rename_edge_attributes(graph, renaming, copy_graph=False, del_old_attr=False)</code>","text":"<p>Rename edge attributes</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Networkx graph</p> required <code>renaming</code> <code>Dict[str, str]</code> <p>Keys are current attribute names. Values are new attribute names.</p> required <code>copy_graph</code> <code>bool</code> <p>If true, copy the graph before renaming attributes.</p> <code>False</code> <code>del_old_attr</code> <code>bool</code> <p>If true, delete the old edge attribute.</p> <code>False</code> <p>Returns:</p> Type Description <code>Graph</code> <p>Graph with renamed attributes. If <code>copy_graph</code> is <code>True</code>, then the copied graph is returned.</p> <code>Graph</code> <p>Otherwise the original graph is returned.</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def rename_edge_attributes(\n    graph: nx.Graph,\n    renaming: Dict[str, str],\n    copy_graph: bool = False,\n    del_old_attr: bool = False,\n) -&gt; nx.Graph:\n    \"\"\"Rename edge attributes\n\n    Args:\n        graph: Networkx graph\n        renaming: Keys are current attribute names. Values are new attribute names.\n        copy_graph: If true, copy the graph before renaming attributes.\n        del_old_attr: If true, delete the old edge attribute.\n\n    Returns:\n        Graph with renamed attributes. If `copy_graph` is `True`, then the copied graph is returned.\n        Otherwise the original graph is returned.\n    \"\"\"\n    G = graph.copy() if copy_graph else graph\n    for u, v, data in G.edges(data=True):\n        for old_name, new_name in renaming.items():\n            G.edges[u, v][new_name] = data[old_name]\n            if del_old_attr:  # delete the old attribute\n                data.pop(old_name)\n    return G\n</code></pre>"},{"location":"api/#tspwplib.rename_node_attributes","title":"<code>rename_node_attributes(graph, renaming, copy_graph=False, del_old_attr=False)</code>","text":"<p>Rename node attributes</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Networkx graph</p> required <code>renaming</code> <code>Dict[str, str]</code> <p>Keys are current attribute names. Values are new attribute names.</p> required <code>copy_graph</code> <code>bool</code> <p>If true, copy the graph before renaming attributes.</p> <code>False</code> <code>del_old_attr</code> <code>bool</code> <p>If true, delete the old node attribute.</p> <code>False</code> <p>Returns:</p> Type Description <code>Graph</code> <p>Graph with renamed attributes. If <code>copy_graph</code> is <code>True</code>, then the copied graph is returned.</p> <code>Graph</code> <p>Otherwise the original graph is returned.</p> Source code in <code>tspwplib/utils.py</code> <pre><code>def rename_node_attributes(\n    graph: nx.Graph,\n    renaming: Dict[str, str],\n    copy_graph: bool = False,\n    del_old_attr: bool = False,\n) -&gt; nx.Graph:\n    \"\"\"Rename node attributes\n\n    Args:\n        graph: Networkx graph\n        renaming: Keys are current attribute names. Values are new attribute names.\n        copy_graph: If true, copy the graph before renaming attributes.\n        del_old_attr: If true, delete the old node attribute.\n\n    Returns:\n        Graph with renamed attributes. If `copy_graph` is `True`, then the copied graph is returned.\n        Otherwise the original graph is returned.\n    \"\"\"\n    G = graph.copy() if copy_graph else graph\n    for u, data in G.nodes(data=True):\n        for old_name, new_name in renaming.items():\n            G.nodes[u][new_name] = data[old_name]\n            if del_old_attr:  # delete the old attribute\n                data.pop(old_name)\n    return G\n</code></pre>"},{"location":"api/#tspwplib.reorder_edge_list_from_root","title":"<code>reorder_edge_list_from_root(edge_list, root)</code>","text":"<p>Reorder a list of edges such that the root vertex is in the first (and last) edge</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <code>EdgeList</code> <p>List of unique, adjacent edges</p> required <code>root</code> <code>Vertex</code> <p>Root vertex</p> required <p>Returns:</p> Type Description <code>EdgeList</code> <p>List of edges. The first (and last) edge will contain the root vertex.</p> <p>Raises:</p> Type Description <code>NodeNotFound</code> <p>If the root vertex is not in any edges.</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def reorder_edge_list_from_root(edge_list: EdgeList, root: Vertex) -&gt; EdgeList:\n    \"\"\"Reorder a list of edges such that the root vertex is in the first (and last) edge\n\n    Args:\n        edge_list: List of unique, adjacent edges\n        root: Root vertex\n\n    Returns:\n        List of edges. The first (and last) edge will contain the root vertex.\n\n    Raises:\n        nx.NodeNotFound: If the root vertex is not in any edges.\n    \"\"\"\n    root_index = -1\n    not_found = nx.NodeNotFound(f\"Root vertex {root} not found in edge list\")\n    n = len(edge_list)\n    if n == 0:\n        raise not_found\n    if n &gt; 1 and root in edge_list[0] and root in edge_list[n - 1]:\n        return edge_list\n    for i in range(n):\n        edge = edge_list[i]\n        if root in edge:\n            root_index = i\n    if root_index == -1:\n        raise not_found\n    reordered_edges = edge_list[root_index:] + edge_list[:root_index]\n    return reordered_edges\n</code></pre>"},{"location":"api/#tspwplib.semi_mst_cost","title":"<code>semi_mst_cost(G, cost_attr='cost', seed=0)</code>","text":"<p>Half of the non-MST-tree edges are left unchanged. The other half are assigned cost as described in mst_cost.</p> <p>The half of edges are chosen with uniform and independent probability.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Undirected, simple graph</p> required <code>cost_attr</code> <code>str</code> <p>Name of the cost attribute of edges</p> <code>'cost'</code> <code>seed</code> <code>int</code> <p>Set the seed of the random number generator</p> <code>0</code> <p>Returns     A new cost function</p> Source code in <code>tspwplib/metric.py</code> <pre><code>def semi_mst_cost(\n    G: nx.Graph, cost_attr: str = \"cost\", seed: int = 0\n) -&gt; SimpleEdgeFunction:\n    \"\"\"Half of the non-MST-tree edges are left unchanged.\n    The other half are assigned cost as described in mst_cost.\n\n    The half of edges are chosen with uniform and independent probability.\n\n    Args:\n        G: Undirected, simple graph\n        cost_attr: Name of the cost attribute of edges\n        seed: Set the seed of the random number generator\n\n    Returns\n        A new cost function\n    \"\"\"\n    # find the cost of the minimum spanning tree in G\n    T = nx.minimum_spanning_tree(G, weight=cost_attr)\n    tree_cost = dict(nx.all_pairs_bellman_ford_path_length(T, weight=cost_attr))\n\n    # get edges not in the tree\n    non_tree_edges = [(u, v) for u, v in G.edges() if not T.has_edge(u, v)]\n    num_non_tree_edges = len(non_tree_edges)\n\n    gen = np.random.default_rng(seed=seed)\n    donot_change_edge_cost = set()\n    while len(non_tree_edges) &gt;= float(num_non_tree_edges) * 0.5:\n        index = gen.integers(0, len(non_tree_edges) - 1)  # get random index\n        donot_change_edge_cost.add(\n            non_tree_edges.pop(index)\n        )  # remove item at random index, add to set\n\n    # set the cost of the new edges\n    new_cost: SimpleEdgeFunction = {}\n    for (u, v), cost in nx.get_edge_attributes(G, cost_attr).items():\n        if (\n            T.has_edge(u, v)\n            or (u, v) in donot_change_edge_cost\n            or (v, u) in donot_change_edge_cost\n        ):\n            new_cost[(u, v)] = cost\n        else:\n            new_cost[(u, v)] = cost + tree_cost[u][v]\n    return new_cost\n</code></pre>"},{"location":"api/#tspwplib.sparsify_by_cost","title":"<code>sparsify_by_cost(G, kappa, cost_attr='cost', seed=0, remove_self_loops=False)</code>","text":"<p>Given vertex i, remove an edge e=(i,j) with probability P[i,j] where the probability function is weighted according to the cost function:</p> <p>$P[i,j] = c(i,j) / C_i$</p> <p>where $C_i$ is the total cost of all edges adjacent to vertex i.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph</p> required <code>kappa</code> <code>int</code> <p>Parameter independent of the input size</p> required <code>cost_attr</code> <code>str</code> <p>Name of the cost attribute on edges</p> <code>'cost'</code> <code>remove_self_loops</code> <code>bool</code> <p>Should self loops have a change of being removed?</p> <code>False</code> <code>seed</code> <code>int</code> <p>Set the random seed for reproducibility of graphs</p> <code>0</code> <p>Returns:</p> Type Description <code>Graph</code> <p>A deep copy of the original graph with edges removed</p> Source code in <code>tspwplib/sparse.py</code> <pre><code>def sparsify_by_cost(\n    G: nx.Graph,\n    kappa: int,\n    cost_attr: str = \"cost\",\n    seed: int = 0,\n    remove_self_loops: bool = False,\n) -&gt; nx.Graph:\n    \"\"\"Given vertex i, remove an edge e=(i,j) with probability P[i,j]\n    where the probability function is weighted according to the cost function:\n\n    $P[i,j] = c(i,j) / C_i$\n\n    where $C_i$ is the total cost of all edges adjacent to vertex i.\n\n    Args:\n        G: Graph\n        kappa: Parameter independent of the input size\n        cost_attr: Name of the cost attribute on edges\n        remove_self_loops: Should self loops have a change of being removed?\n        seed: Set the random seed for reproducibility of graphs\n\n    Returns:\n        A deep copy of the original graph with edges removed\n    \"\"\"\n    random.seed(seed)\n    graph_copy = deepcopy(G)\n    vertex_list = list(graph_copy.nodes())\n    while graph_copy.number_of_edges() &gt; graph_copy.number_of_nodes() * kappa:\n        # choose vertex randomly\n        u = random.choice(vertex_list)\n        u_has_self_loop = graph_copy.has_edge(u, u)\n        u_neighbors = list(graph_copy.neighbors(u))\n        if u_has_self_loop and not remove_self_loops:\n            u_neighbors.remove(u)\n        if len(u_neighbors) &gt; 0:\n            # draw a random number from uniform and independent distribution (UID)\n            threshold = random.random()\n\n            # the total cost of all adjacent edges is the denominator\n            cost_of_edges = float(\n                total_cost_of_adjacent_edges(graph_copy, u, cost_attr=cost_attr)\n            )\n            chosen_vertex = None\n\n            if u_has_self_loop and not remove_self_loops:\n                cost_of_edges -= graph_copy.get_edge_data(u, u)[cost_attr]\n\n            if cost_of_edges == 0:\n                chosen_vertex = random.choice(u_neighbors)\n\n            else:\n                # iterate over neighbors to check if the edge has been selected\n                probability_so_far = 0.0\n                for v in u_neighbors:\n                    # weight probability of choosing an edges by the cost\n                    edge_prob = (\n                        float(graph_copy.get_edge_data(u, v)[cost_attr]) / cost_of_edges\n                    )\n                    if probability_so_far + edge_prob &gt;= threshold and (\n                        remove_self_loops or u != v\n                    ):\n                        # edge found! break here\n                        chosen_vertex = v\n                        break\n                    probability_so_far += edge_prob\n            graph_copy.remove_edge(u, chosen_vertex)\n    return graph_copy\n</code></pre>"},{"location":"api/#tspwplib.sparsify_uid","title":"<code>sparsify_uid(G, kappa, remove_self_loops=False, seed=0)</code>","text":"<p>Remove edges with uniform and independent (uid) probability until the number of edges equals kappa * number of nodes</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph</p> required <code>kappa</code> <code>int</code> <p>Parameter independent of the input size</p> required <code>remove_self_loops</code> <code>bool</code> <p>Should self loops have a change of being removed?</p> <code>False</code> <code>seed</code> <code>int</code> <p>Set the random seed</p> <code>0</code> <p>Returns:</p> Type Description <code>Graph</code> <p>Graph with kappa * V edges where V is the number of nodes</p> Notes <p>A copy of the graph is made and returned. The original graph is unedited.</p> Source code in <code>tspwplib/sparse.py</code> <pre><code>def sparsify_uid(\n    G: nx.Graph,\n    kappa: int,\n    remove_self_loops: bool = False,\n    seed: int = 0,\n) -&gt; nx.Graph:\n    \"\"\"Remove edges with uniform and independent (uid) probability until\n    the number of edges equals kappa * number of nodes\n\n    Args:\n        G: Graph\n        kappa: Parameter independent of the input size\n        remove_self_loops: Should self loops have a change of being removed?\n        seed: Set the random seed\n\n    Returns:\n        Graph with kappa * V edges where V is the number of nodes\n\n    Notes:\n        A copy of the graph is made and returned. The original graph is unedited.\n    \"\"\"\n    random.seed(seed)\n    graph_copy = deepcopy(G)\n    vertex_list = list(graph_copy.nodes())\n    while graph_copy.number_of_edges() &gt; graph_copy.number_of_nodes() * kappa:\n        # choose vertex randomly\n        u = random.choice(vertex_list)\n        if graph_copy.degree(u) &gt; 0:\n            # choose a neighbor randomly\n            v = random.choice(list(graph_copy.neighbors(u)))\n            # remove edge if it is not a self loop\n            if remove_self_loops or u != v:\n                graph_copy.remove_edge(u, v)\n    return graph_copy\n</code></pre>"},{"location":"api/#tspwplib.split_graph_from_properties","title":"<code>split_graph_from_properties(edge_properties, edge_attr_to_split='cost', edge_attr_to_vertex='length', new_vertex_attr='prize', old_edge_attr='old_edge')</code>","text":"<p>Split edges with properties and create undirected simple graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_properties</code> <code>EdgeProperties</code> <p>Keys are edges. Values are dicts of edge attributes.</p> required <code>edge_attr_to_split</code> <code>str</code> <p>Name of edge attribute. Assign half the value to each split edge.</p> <code>'cost'</code> <code>edge_attr_to_vertex</code> <code>str</code> <p>Name of edge attribute. Assign edge value to a new vertex attribute.</p> <code>'length'</code> <code>new_vertex_attr</code> <code>str</code> <p>Name of the newly created vertex attribute.</p> <code>'prize'</code> <code>old_edge_attr</code> <code>str</code> <p>Name of the newly created attribute for the old edge ID.</p> <code>'old_edge'</code> <p>Returns:</p> Type Description <code>Graph</code> <p>Undirected simple graph with edge attributes for cost, prize and old_edge</p> Notes <p>To get the original_edge that a split edge represents, access the 'old_edge' attribute</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def split_graph_from_properties(\n    edge_properties: EdgeProperties,\n    edge_attr_to_split: str = \"cost\",\n    edge_attr_to_vertex: str = \"length\",\n    new_vertex_attr: str = \"prize\",\n    old_edge_attr: str = \"old_edge\",\n) -&gt; nx.Graph:\n    \"\"\"Split edges with properties and create undirected simple graph.\n\n    Args:\n        edge_properties: Keys are edges. Values are dicts of edge attributes.\n        edge_attr_to_split: Name of edge attribute. Assign half the value to each split edge.\n        edge_attr_to_vertex: Name of edge attribute. Assign edge value to a new vertex attribute.\n        new_vertex_attr: Name of the newly created vertex attribute.\n        old_edge_attr: Name of the newly created attribute for the old edge ID.\n\n    Returns:\n        Undirected simple graph with edge attributes for cost, prize and old_edge\n\n    Notes:\n        To get the original_edge that a split edge represents, access the 'old_edge' attribute\n    \"\"\"\n    # check that every edge has an attribute to split and an attr to move to vertex\n    is_edge_attr_to_split = True\n    is_edge_attr_to_vertex = True\n    for data in edge_properties.values():\n        if not edge_attr_to_split in data:\n            is_edge_attr_to_split = False\n        if not edge_attr_to_vertex in data:\n            is_edge_attr_to_vertex = False\n\n    # split edges and create lookups\n    edge_list = list(edge_properties.keys())\n    splits = split_edges(edge_list)\n    to_split = lookup_to_split(edge_list, splits)\n    from_split = lookup_from_split(edge_list, splits)\n\n    # create graph and assign prizes and costs\n    G = nx.Graph()\n    G.add_edges_from(splits)\n    if is_edge_attr_to_vertex:\n        prize = prize_from_weighted_edges(\n            {edge: item[edge_attr_to_vertex] for edge, item in edge_properties.items()},\n            to_split,\n        )\n        nx.set_node_attributes(G, 0.0, name=new_vertex_attr)\n        nx.set_node_attributes(G, prize, name=new_vertex_attr)\n\n    if is_edge_attr_to_split:\n        cost = split_edge_cost(\n            {edge: item[edge_attr_to_split] for edge, item in edge_properties.items()},\n            to_split,\n        )\n        nx.set_edge_attributes(G, 0.0, name=edge_attr_to_split)\n        nx.set_edge_attributes(G, cost, name=edge_attr_to_split)\n    nx.set_edge_attributes(G, from_split, name=old_edge_attr)\n    return G\n</code></pre>"},{"location":"api/#tspwplib.split_head","title":"<code>split_head(biggest_vertex, original_vertex)</code>","text":"<p>Get the split head of the vertex</p> <p>Parameters:</p> Name Type Description Default <code>biggest_vertex</code> <code>Vertex</code> <p>The vertex with the biggest id in the original graph</p> required <code>original_vertex</code> <code>Vertex</code> <p>Vertex in the original graph</p> required <p>Returns:</p> Type Description <code>Vertex</code> <p>New split vertex that is a head of all arcs in the asymmetric graph</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def split_head(biggest_vertex: Vertex, original_vertex: Vertex) -&gt; Vertex:\n    \"\"\"Get the split head of the vertex\n\n    Args:\n        biggest_vertex: The vertex with the biggest id in the original graph\n        original_vertex: Vertex in the original graph\n\n    Returns:\n        New split vertex that is a head of all arcs in the asymmetric graph\n    \"\"\"\n    return 2 * (biggest_vertex + 1) + original_vertex\n</code></pre>"},{"location":"api/#tspwplib.split_tail","title":"<code>split_tail(biggest_vertex, original_vertex)</code>","text":"<p>Get the split tail of the vertex</p> <p>Parameters:</p> Name Type Description Default <code>biggest_vertex</code> <code>Vertex</code> <p>The vertex with the biggest id in the original graph</p> required <code>original_vertex</code> <code>Vertex</code> <p>Vertex in the original graph</p> required <p>Returns:</p> Type Description <code>Vertex</code> <p>New split vertex that is a tail of all arcs in the asymmetric graph</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def split_tail(biggest_vertex: Vertex, original_vertex: Vertex) -&gt; Vertex:\n    \"\"\"Get the split tail of the vertex\n\n    Args:\n        biggest_vertex: The vertex with the biggest id in the original graph\n        original_vertex: Vertex in the original graph\n\n    Returns:\n        New split vertex that is a tail of all arcs in the asymmetric graph\n    \"\"\"\n    return biggest_vertex + 1 + original_vertex\n</code></pre>"},{"location":"api/#tspwplib.tail_prize","title":"<code>tail_prize(prize)</code>","text":"<p>Get the prize of the split tail</p> <p>Parameters:</p> Name Type Description Default <code>prize</code> <code>int</code> <p>The prize of a vertex</p> required <p>Returns     Split tail prize</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def tail_prize(prize: int) -&gt; int:\n    \"\"\"Get the prize of the split tail\n\n    Args:\n        prize: The prize of a vertex\n\n    Returns\n        Split tail prize\n    \"\"\"\n    return math.floor(prize / 2.0)\n</code></pre>"},{"location":"api/#tspwplib.to_simple_undirected","title":"<code>to_simple_undirected(G)</code>","text":"<p>Given an undirected multigraph, multi edges to create a simple undirected graph.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>MultiGraph</code> <p>Undirected networkx multi graph.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>Undirected networkx simple graph with no multi edges.</p> Notes <p>Assumes the vertex ids are integers.</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def to_simple_undirected(G: nx.MultiGraph) -&gt; nx.Graph:\n    \"\"\"Given an undirected multigraph, multi edges to create a simple undirected graph.\n\n    Args:\n        G: Undirected networkx multi graph.\n\n    Returns:\n        Undirected networkx simple graph with no multi edges.\n\n    Notes:\n        Assumes the vertex ids are integers.\n    \"\"\"\n    if not isinstance(G, nx.MultiGraph) and isinstance(G, nx.Graph):\n        return G\n    if isinstance(G, nx.DiGraph):\n        raise TypeError(\"Directed graphs are not valid for this method\")\n    simple_graph = nx.Graph()\n\n    # copy graph attributes to new graph\n    for key, value in simple_graph.graph.items():\n        simple_graph.graph[key] = value\n\n    # copy vertex attributes\n    for v, data in G.nodes(data=True):\n        simple_graph.add_node(v, **data)\n\n    biggest = biggest_vertex_id_from_graph(G)\n\n    for u, v, k, data in G.edges.data(keys=True):\n        if u == v and k &gt; 0:\n            message = \"Self loop found with key greater than zero: \"\n            message += \"implies there is more than one self loop on this vertex.\"\n            raise UnexpectedSelfLoopException(message)\n\n        # the first multi edge - add all data to new graph edge\n        if k == 0:\n            simple_graph.add_edge(u, v, **data)\n\n        # multi edge - create new vertex for the source if it does not yet exist\n        elif k &gt; 0:\n            vertex_data = G.nodes[u]\n            dummy = new_dummy_vertex(u, k, biggest)\n            simple_graph.add_node(dummy, **vertex_data)\n            simple_graph.add_edge(u, dummy, **data)\n            simple_graph.add_edge(dummy, v, **data)\n        else:\n            raise ValueError(\"Negative key for edge.\")\n\n    return simple_graph\n</code></pre>"},{"location":"api/#tspwplib.to_vertex_dataframe","title":"<code>to_vertex_dataframe(graph)</code>","text":"<p>Convert graph vertices to pandas dataframe</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Input graph</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas dataframe with vertex set as index</p> Source code in <code>tspwplib/converter.py</code> <pre><code>def to_vertex_dataframe(graph: nx.Graph) -&gt; pd.DataFrame:\n    \"\"\"Convert graph vertices to pandas dataframe\n\n    Args:\n        graph: Input graph\n\n    Returns:\n        pandas dataframe with vertex set as index\n    \"\"\"\n    vertex_data = list(map(lambda x: dict(vertex=x[0], **x[1]), graph.nodes(data=True)))\n    vertex_df = pd.DataFrame(vertex_data)\n    vertex_df = vertex_df.set_index(\"vertex\")\n    return vertex_df\n</code></pre>"},{"location":"api/#tspwplib.total_cost","title":"<code>total_cost(costs, edges)</code>","text":"<p>Total cost of edges</p> <p>Parameters:</p> Name Type Description Default <code>costs</code> <code>EdgeFunction</code> <p>Mapping from edges to costs</p> required <code>edges</code> <code>EdgeList</code> <p>List of edges</p> required <p>Returns:</p> Type Description <code>int</code> <p>Total cost of edges</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def total_cost(costs: EdgeFunction, edges: EdgeList) -&gt; int:\n    \"\"\"Total cost of edges\n\n    Args:\n        costs: Mapping from edges to costs\n        edges: List of edges\n\n    Returns:\n        Total cost of edges\n    \"\"\"\n    sum_cost = 0\n    for edge in edges:\n        try:\n            sum_cost += costs[edge]\n        except KeyError:\n            try:\n                u = edge[0]\n                v = edge[1]\n                sum_cost += costs[(v, u)]\n            except KeyError as second_key_error:\n                raise KeyError(\n                    \"Edge ({u},{v}) or ({v},{u}) do not exist in costs map\".format(\n                        u=u, v=v\n                    )\n                ) from second_key_error\n        except Exception as error:\n            raise KeyError(f\"{edge} does not exist in cost map\") from error\n    return sum_cost\n</code></pre>"},{"location":"api/#tspwplib.total_cost_networkx","title":"<code>total_cost_networkx(graph, walk)</code>","text":"<p>Get the total cost of edges in a walk of the networkx graph</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Undirected input graph with cost attribute</p> required <code>walk</code> <code>VertexList</code> <p>A sequence of adjacent vertices</p> required <p>Returns:</p> Type Description <code>int</code> <p>Total cost of edges in the walk</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def total_cost_networkx(graph: nx.Graph, walk: VertexList) -&gt; int:\n    \"\"\"Get the total cost of edges in a walk of the networkx graph\n\n    Args:\n        graph: Undirected input graph with cost attribute\n        walk: A sequence of adjacent vertices\n\n    Returns:\n        Total cost of edges in the walk\n    \"\"\"\n    edges_in_tour = edge_list_from_walk(walk)\n    cost_attr = nx.get_edge_attributes(graph, EdgeFunctionName.cost.value)\n    return total_cost(cost_attr, edges_in_tour)\n</code></pre>"},{"location":"api/#tspwplib.total_prize","title":"<code>total_prize(prizes, vertices)</code>","text":"<p>Total prize of vertices</p> <p>Parameters:</p> Name Type Description Default <code>prizes</code> <code>Mapping[Vertex, int]</code> <p>A mapping from vertices to prizes, e.g. dict, property map</p> required <code>vertices</code> <code>Iterable[Vertex]</code> <p>List of vertices in the prizes map</p> required <p>Returns:</p> Type Description <code>int</code> <p>Total prize of vertices</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def total_prize(prizes: Mapping[Vertex, int], vertices: Iterable[Vertex]) -&gt; int:\n    \"\"\"Total prize of vertices\n\n    Args:\n        prizes: A mapping from vertices to prizes, e.g. dict, property map\n        vertices: List of vertices in the prizes map\n\n    Returns:\n        Total prize of vertices\n    \"\"\"\n    sum_prize: int = 0\n    for vertex in vertices:\n        sum_prize += prizes[vertex]\n    return sum_prize\n</code></pre>"},{"location":"api/#tspwplib.total_prize_of_tour","title":"<code>total_prize_of_tour(prizes, tour)</code>","text":"<p>Total prize of unique vertices in the tour</p> <p>Parameters:</p> Name Type Description Default <code>prizes</code> <code>Mapping[Vertex, int]</code> <p>A mapping from vertices to prizes, e.g. dict, property map</p> required <code>tour</code> <code>VertexList</code> <p>List of vertices in the prizes map</p> required <p>Returns:</p> Type Description <code>int</code> <p>Total prize of the tour</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def total_prize_of_tour(prizes: Mapping[Vertex, int], tour: VertexList) -&gt; int:\n    \"\"\"Total prize of unique vertices in the tour\n\n    Args:\n        prizes: A mapping from vertices to prizes, e.g. dict, property map\n        tour: List of vertices in the prizes map\n\n    Returns:\n        Total prize of the tour\n    \"\"\"\n    return total_prize(prizes, set(tour))\n</code></pre>"},{"location":"api/#tspwplib.uniform_random_cost","title":"<code>uniform_random_cost(edge_list, min_value=1, max_value=100, seed=0)</code>","text":"<p>Generate a cost function for each edge drawn from a uniform and independant probability</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <code>SimpleEdgeList</code> <p>List of edges in graph</p> required <code>min_value</code> <code>int</code> <p>Minimum value the cost can take (inclusive)</p> <code>1</code> <code>max_value</code> <code>int</code> <p>Maximum value the cost can take (inclusive)</p> <code>100</code> <code>seed</code> <code>int</code> <p>Set the seed of the random number generator</p> <code>0</code> <p>Returns:</p> Type Description <code>SimpleEdgeFunction</code> <p>Edge cost function</p> Source code in <code>tspwplib/metric.py</code> <pre><code>def uniform_random_cost(\n    edge_list: SimpleEdgeList, min_value: int = 1, max_value: int = 100, seed: int = 0\n) -&gt; SimpleEdgeFunction:\n    \"\"\"Generate a cost function for each edge drawn from a uniform and independant probability\n\n    Args:\n        edge_list: List of edges in graph\n        min_value: Minimum value the cost can take (inclusive)\n        max_value: Maximum value the cost can take (inclusive)\n        seed: Set the seed of the random number generator\n\n    Returns:\n        Edge cost function\n    \"\"\"\n    cost: SimpleEdgeFunction = {}\n    random.seed(seed)\n    for u, v in edge_list:\n        cost[(u, v)] = random.randint(min_value, max_value)\n    return cost\n</code></pre>"},{"location":"api/#tspwplib.vertex_set_from_edge_list","title":"<code>vertex_set_from_edge_list(edge_list)</code>","text":"<p>Get a set of vertices from a list of edges</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <code>EdgeList</code> <p>List of edges</p> required <p>Returns:</p> Type Description <code>Set[Vertex]</code> <p>Set of vertices in the edge list</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def vertex_set_from_edge_list(edge_list: EdgeList) -&gt; Set[Vertex]:\n    \"\"\"Get a set of vertices from a list of edges\n\n    Args:\n        edge_list: List of edges\n\n    Returns:\n        Set of vertices in the edge list\n    \"\"\"\n    return set(itertools.chain.from_iterable(edge_list))\n</code></pre>"},{"location":"api/#tspwplib.walk_from_edge_list","title":"<code>walk_from_edge_list(edge_list)</code>","text":"<p>Get a walk from a list of unique, adjacent edges</p> <p>Parameters:</p> Name Type Description Default <code>edge_list</code> <code>EdgeList</code> <p>List of unique edges that are adjacent in the graph</p> required <p>Returns:</p> Type Description <code>VertexList</code> <p>List of vertices in walk of edges</p> <p>Raises:</p> Type Description <code>EdgesNotAdjacentException</code> <p>When two edges in the walk are not adjacent</p> Source code in <code>tspwplib/walk.py</code> <pre><code>def walk_from_edge_list(edge_list: EdgeList) -&gt; VertexList:\n    \"\"\"Get a walk from a list of unique, adjacent edges\n\n    Args:\n        edge_list: List of unique edges that are adjacent in the graph\n\n    Returns:\n        List of vertices in walk of edges\n\n    Raises:\n        EdgesNotAdjacentException: When two edges in the walk are not adjacent\n    \"\"\"\n    walk: VertexList = []\n    if len(edge_list) == 0:\n        return walk\n\n    first_edge = edge_list[0]\n    if len(edge_list) == 1:\n        walk.append(first_edge[0])\n        walk.append(first_edge[1])\n        return walk\n\n    second_edge = edge_list[1]\n    if first_edge[0] == second_edge[0] or first_edge[0] == second_edge[1]:\n        current = first_edge[0]\n        walk.append(first_edge[1])\n    else:\n        current = first_edge[1]\n        walk.append(first_edge[0])\n\n    for i in range(1, len(edge_list)):\n        walk.append(current)\n        edge = edge_list[i]\n        u = edge[0]\n        v = edge[1]\n        if u == current:\n            current = v\n        elif v == current:\n            current = u\n        else:\n            message = f\"Edges in the edge list must be adjacent, but edge {u} - {v}\"\n            message += (\n                f\" is not adjacent to vertex {current} from previous edge in list.\"\n            )\n            raise EdgesNotAdjacentException(message)\n    walk.append(current)\n    return walk\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Install via pip:</p> <pre><code>pip install tspwplib\n</code></pre> <p>You will also need access to the OPLib dataset:</p> <pre><code>git clone https://github.com/bcamath-ds/OPLib.git\n</code></pre> <p>Optionally you may also want to download the original tsplib95 dataset:</p> <pre><code>git clone https://github.com/rhgrant10/tsplib95.git\n</code></pre> <p>It is convenient to define environment variables to define the location of OPLib and tsplib95:</p> <pre><code>TSPLIB_ROOT=\"$(pwd)/tsplib95/archives/problems/tsp\"\nOPLIB_ROOT=\"$(pwd)/OPLib/\"\n</code></pre> <p>Replace <code>$(pwd)</code> with the appropriate directory where you cloned OPLib and tsplib95.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>You can also use docker:</p> <pre><code>docker pull patrickohara/tspwplib:latest\n</code></pre> <p>To build the tspwplib docker image:</p> <pre><code>docker build -t patrickohara/tspwplib:latest .\n</code></pre>"}]}